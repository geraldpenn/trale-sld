Binary files trale.orig/bin/ginhooks.o and trale/bin/ginhooks.o differ
Binary files trale.orig/bin/graphs.o and trale/bin/graphs.o differ
Binary files trale.orig/bin/gsldhooks.o and trale/bin/gsldhooks.o differ
Binary files trale.orig/bin/interp.o and trale/bin/interp.o differ
Binary files trale.orig/bin/printlength.o and trale/bin/printlength.o differ
Binary files trale.orig/bin/samsort.o and trale/bin/samsort.o differ
Binary files trale.orig/bin/sets.o and trale/bin/sets.o differ
Binary files trale.orig/bin/step_id_display_hooks.o and trale/bin/step_id_display_hooks.o differ
Binary files trale.orig/bin/strings.o and trale/bin/strings.o differ
diff -rN trale.orig/debugger/ginhooks.pl trale/debugger/ginhooks.pl
0a1,34
> % ------------------------------------------------------------------------------
> %
> % This file defines hooks for taking debugger commands from the graphical SLD.
> %
> % Author: Kilian Evang
> %
> % ------------------------------------------------------------------------------
> 
> :- use_module(library(system), [sleep/1]).
> 
> socket_info_available :-
>   current_predicate(socket_info, socket_info(_, _)),
>   socket_info(_, _).
> 
> get_reply_hook(Reply) :-
>   socket_info_available
> % Will have to wait until SP4:
> %  -> (get_reply_from_terminal_or_socket(Reply))
>   -> get_reply_from_socket(Reply)
>    ; get_reply_from_terminal_simple(Reply).
> 
> get_reply_from_socket(Reply) :-
>   socket_info(_, Stream),
>   get_code(Stream, Reply),
>   (    Reply =:= 10
>     -> true
>      ; skip_line(Stream)),
>   nl.
> 
> get_reply_from_terminal_simple(Reply) :-
>   get_code(Reply),
>   (    Reply =:= 10
>     -> true
>      ; skip_line).
diff -rN trale.orig/debugger/gsldhooks.pl trale/debugger/gsldhooks.pl
0a1,20
> % ------------------------------------------------------------------------------
> %
> % This file implements hooks for the purposes of the graphical source level
> % debugger
> %
> % Author: Kilian Evang
> %
> % ------------------------------------------------------------------------------
> 
> announce_step_hook(Command,Line).
> 
> announce_step_hook.
> 
> announce_port_hook(call).
> 
> announce_port_hook(fail).
> 
> announce_port_hook(exit).
> 
> announce_port_hook(redo).
\ No newline at end of file
diff -rN trale.orig/debugger/interp.pl trale/debugger/interp.pl
405a406
>   announce_parse_begin(Ws),
852a854,857
>   (current_predicate(
>        announce_edge_added_hook,announce_edge_added_hook(_,_,_,_)) ->
>      call_all(announce_edge_added_hook(N,Left,Right,RuleName)) ;
>      true),
857a863,866
>   (current_predicate(
>        announce_edge_retrieved_hook,announce_edge_retrieved_hook(_)) ->
>      call_all(announce_edge_retrieved_hook(N)) ;
>      true),
1868c1877,1881
< d_meta_interp(PortCommand,Line,Goal) :-	       
---
> d_meta_interp(PortCommand,Line,Goal) :-
>   d_meta_interp(PortCommand,Line,Goal,false).
> 
> d_meta_interp(PortCommand,Line,Goal,Retrying) :-
>   (Retrying -> true ; announce_step(PortCommand,Line,StepID)),
1873c1886
<        d_exit_redo(PortCommand,Line,DetFlag)),
---
>        d_exit_redo(StepID,PortCommand,Line,DetFlag)),
1875c1888
<   d_meta_interp(PortCommand,Line,Goal)),
---
>   d_meta_interp(PortCommand,Line,Goal,true)),
1888a1902,1955
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Announcement of parsing steps
> 
> :- dynamic last_step_id/1.
> 
> clear_hook :-
>   retractall(last_step_id(_)),
>   asserta(last_step_id(0)).
> 
> announce_parse_begin(Words) :-
>   current_predicate(announce_parse_begin_hook,announce_parse_begin_hook(_)) ->
>     call_all(announce_parse_begin_hook(Words)) ;
>     true.
> 
> announce_step(Command,Line,StepID) :-
>   parsing(_) -> (
>     retract(last_step_id(OldStepID)),
>     StepID is OldStepID + 1,
>     asserta(last_step_id(StepID)),
>     current_predicate(announce_step_hook,announce_step_hook(_,_,_)) ->
>       call_all(announce_step_hook(StepID,Command,Line)) ;
>       true
>   ) ; true.
> 
> announce_call :-
>   parsing(_) -> (
>     current_predicate(announce_call_hook,announce_call_hook) ->
>       call_all(announce_call_hook) ; true
>   ) ; true.
> 
> announce_fail :-
>   parsing(_) -> (
>     current_predicate(announce_fail_hook,announce_fail_hook) ->
>       call_all(announce_fail_hook) ; true
>   ) ; true.
> 
> announce_finished :-
>   parsing(_) -> (
>     current_predicate(announce_finished_hook,announce_finished_hook) ->
>       call_all(announce_finished_hook) ; true
>   ) ; true.
> 
> announce_exit :-
>   parsing(_) -> (
>     current_predicate(announce_exit_hook,announce_exit_hook) ->
>       call_all(announce_exit_hook) ; true
>   ) ; true.
> 
> announce_redo(StepID) :-
>   parsing(_) -> (
>     current_predicate(announce_redo_hook,announce_redo_hook(_)) ->
>       call_all(announce_redo_hook(StepID)) ; true
>   ) ; true.
> 
1901a1969
>     announce_call,
1916c1984,1985
<   
---
> 
>     (failure_driven(Command) -> announce_finished ; announce_fail),
1938c2007
< %	    ; nl(user_error), flush_output(user_error), abort
---
> %	    ; nl(user_error), flush_output(user_error), f
1954c2023
<         ttyget0(Reply),
---
>         get_reply(Reply),
1969c2038
<         ttyget0(Reply),
---
>         get_reply(Reply),
1980c2049
<       ttyget0(Reply),
---
>       get_reply(Reply),
1986d2054
<   skip_line,
1989c2057
<   !,skip_line,
---
>   !,
1992c2060
<   !,skip_line,
---
>   !,
1996c2064
<   !,skip_line.
---
>   !.
1998c2066
<   !,skip_line,
---
>   !,
2002c2070
<   !,skip_line,
---
>   !,
2006c2074
<   !,skip_line,
---
>   !,
2010c2078
<   !,skip_line,
---
>   !,
2014c2082
<   !,skip_line,
---
>   !,
2018c2086
<   !,skip_line,
---
>   !,
2031c2099
<   ttyget0(Reply),
---
>   get_reply(Reply),
2036c2104
<   !,skip_line,
---
>   !,
2052d2119
<   skip_line,
2065c2132
<       ttyget0(Reply),
---
>       get_reply(Reply),
2077c2144
<       ttyget0(Reply),
---
>       get_reply(Reply),
2089c2156
<       ttyget0(Reply),
---
>       get_reply(Reply),
2096c2163
<     ttyget0(Reply),
---
>     get_reply(Reply),
2102d2168
<   skip_line,
2105c2171
<   !,skip_line,
---
>   !,
2110c2176
<   !,skip_line,
---
>   !,
2112,2114c2178,2180
< daf_act(114,_Skip,Command,Line) :- % (r)etry
<   !,skip_line,
<   d_call_fail(Command,Line).
---
> daf_act(114,_,_,_) :- % (r)etry
>   !,
>   raise_exception(ale_retry).
2118c2184
<   !,skip_line,
---
>   !,
2123c2189
<   !,skip_line,
---
>   !,
2127c2193
<   !,skip_line,
---
>   !,
2131c2197
<   !,skip_line,
---
>   !,
2135c2201
<   !,skip_line,
---
>   !,
2148c2214
<   ttyget0(Reply),
---
>   get_reply(Reply),
2151c2217
<   !,skip_line,
---
>   !,
2167d2232
<   skip_line,
2174c2239
< d_exit_redo(Command,Line,DetFlag) :-
---
> d_exit_redo(_,Command,Line,DetFlag) :-
2184a2250
>      announce_exit,
2188c2254
< d_exit_redo(Command,Line,_) :-
---
> d_exit_redo(StepID,Command,Line,_) :-
2199a2266
>    announce_redo(StepID),
2210c2277
<       ttyget0(Reply),
---
>       get_reply(Reply),
2221c2288
<       ttyget0(Reply),
---
>       get_reply(Reply),
2232c2299
<       ttyget0(Reply),
---
>       get_reply(Reply),
2239c2306
<     ttyget0(Reply),
---
>     get_reply(Reply),
2245c2312
<   skip_line,
---
> write(oha),
2248c2315
<   !,skip_line,
---
>   !,
2251c2318
<   !,skip_line,
---
>   !,
2255c2322
<   !,skip_line.
---
>   !.
2257c2324
<   !,skip_line,
---
>   !,
2262c2329
<   !,skip_line,
---
>   !,
2266c2333
<   !,skip_line,
---
>   !,
2270c2337
<   !,skip_line,
---
>   !,
2274c2341
<   !,skip_line,
---
>   !,
2278c2345
<   !,skip_line,
---
>   !,
2291c2358
<   ttyget0(Reply),
---
>   get_reply(Reply),
2294c2361
<   !,skip_line,
---
>   !,
2310d2376
<   skip_line,
2328c2394
<         ttyget0(Reply),
---
>         get_reply(Reply),
2345c2411
<         ttyget0(Reply),
---
>         get_reply(Reply),
2357c2423
<       ttyget0(Reply),
---
>       get_reply(Reply),
2363d2428
<   skip_line,
2366c2431
<   !,skip_line,
---
>   !,
2369c2434
<   !,skip_line,
---
>   !,
2374c2439
<   !,skip_line,
---
>   !,
2377c2442
<   !,skip_line,
---
>   !,
2380c2445
<   !,skip_line,
---
>   !,
2387c2452
<   !,skip_line,
---
>   !,
2392c2457
<   !,skip_line,
---
>   !,
2396c2461
<   !,skip_line,
---
>   !,
2400c2465
<   !,skip_line,
---
>   !,
2404c2469
<   !,skip_line,
---
>   !,
2417c2482
<   ttyget0(Reply),
---
>   get_reply(Reply),
2420c2485
<   !,skip_line,
---
>   !,
2437d2501
<   skip_line,
2440a2505,2516
>   
> % gg_reply(-Reply)
> %   Called when waiting at a step to get the reply of the user or the steering
> %   application. If the hook gg_reply/1 is defined, it will be used. If not,
> %   the default strategy (read one character from the terminal) will be used.
> get_reply(Reply) :-
>   current_predicate(get_reply_hook, get_reply_hook(_))
>   -> get_reply_hook(Reply)
>    ; get_code(Reply),
>      (Reply =:= 10
>       -> true
>        ; skip_line).
diff -rN trale.orig/debugger/interp.pl~ trale/debugger/interp.pl~
0a1,4170
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % ALE source-level debugger, version 3.2.1
> % Gerald Penn, December, 2001
> % using Emacs-lisp support for the SICStus Prolog source-level debugger by
> %  Rozman Tamas and Emil Astrom.
> %
> % Copyright (C) 1997--1999, 2001, Gerald Penn
> 
> % For use only with SICStus Prolog 3.8.6 or higher
> % To use without emacs, use noemacs/0, otherwise use XEmacs 20.3 or higher
> %
> % For installation instructions, see INSTALL
> %
> % TO RUN WITH XEMACS
> % 0. Make sure that your EPROLOG environment variable is set to the command
> %    that will run SICStus Prolog 3.8.6 or higher (not necessary if the command
> %    is 'sicstus')
> % 1. Run XEmacs
> % 2  Load an ALE grammar file in Prolog major mode.
> % 3. Run SICStus prolog as an inferior process with M-x run-prolog
> % 4. ?- compile(debugger).
> % 5. use dcompile_gram/1 to compile grammar files for debugging,
> %    drec/1 for parsing, dgen/1 for generation, and dquery/1 for 
> %    definite clause resolution
> %
> % TO RUN WITHOUT XEMACS
> % 1. Run SICStus Prolog
> % 2. ?- compile(debugger).
> % 3. ?- noemacs.           % you can put this at the end of debugger.pl too
> % 4. use dcompile_gram/1 to compile grammar files for debugging,
> %    drec/1 for parsing, dgen/1 for generation, and dquery/1 for definite 
> %    clause resolution
> 
> % Bug corrected: d_lex_rule/9 must deref TagIn-SVsIn before calling d_add_to/7
> % 6/11/98 - G. Penn
> 
> % Bug corrected: missing cuts in label_query_arg/2.
> % 6/18/98 - G. Penn
> 
> % Added generator to source-level debugger
> % 6/18/98 - G. Penn
> 
> % Reclassified lex_pivot_unify port as kind, lr.
> % 7/2/98 - G. Penn
> 
> % Updated debugger for shallow cuts and new parser.
> % 5/15/99 - G. Penn
> 
> % Bug corrected: d_add_dtrs/13 was unbinding inequations with final cats>
> % daughters.
> % 5/16/99 - G. Penn
> 
> % Added debugging ports for compile-time EFD closure.
> % 5/16/99 - G. Penn
> 
> % Added fail-recognition to parser and two-place shallow cuts.
> % 5/22/99 - G. Penn
> 
> % Bug corrected: empty_cat/7 failure clause needs to be added if no
> %  empty cats so that get_edge/9 will work.
> % 5/22/99 - G. Penn
> 
> % Bug corrected: Prolog debugger state was not maintained properly if hook
> %  failed.
> % 5/22/99 - G. Penn
> 
> % Changed fail port to display 'Finished:' with failure-driven loops like
> %  chart parser.
> % 5/22/99 - G. Penn
> 
> % Bug corrected: changed order of label_body/6 clauses so that shallow cuts are
> %  matched before disjunctions.
> % 5/22/99 - G. Penn
> 
> % Bug corrected: d_match_cat_to_next_cat/12 clause was missing d_ prefix.
> % 12/11/01 - G. Penn
> 
> % Bug corrected: BLs did not need to be threaded through label_term/5.
> % 12/13/01 - G. Penn
> 
> % Bug corrected: subsumption compilation had not been added to pcompile
> %  chain, no_subsumption flag was not checked during EFD-closure, and
> %  lists had not been replaced by association lists in d_minimise_emptys/3.
> % 12/14/01 - G. Penn
> 
> % Tokeniser now uses new SICStus read_term/2 layout option - Mildner's
> %  source_debug module eliminated.
> % 12/14/01 - G. Penn
> 
> % Rewrote interpreter for ALE 3.3 - includes using internal DB for skip
> %  counter for safety with co-routining, and modelling d_query_goal/5
> %  after ALE's query_goal/5 (with zipping).
> % 7/28/02 - G. Penn
> 
> % Bug corrected: d_query_goal/5 contained a cut exception-handler - that
> %  belongs in top-level dquery/1 because d_solve_goal/3 also calls this
> %  (through d_query/1).
> % 7/29/02 - G. Penn
> 
> % Bug corrected: cut exception-handler must decrement skip counter because
> %  cut exception passes through comp_clause/2 ports.
> % 7/29/02 - G. Penn
> 
> % Bug corrected: d_query_goal0/6 mapped LGoal1 to G2 in its ;/2 clause.
> % 8/5/02 - G. Penn
> 
> % Bug corrected: nv_replace_ldesc/5 did not remove ltype/2 wrapper in type clause.
> % 8/5/02 - G. Penn
> 
> % Bug corrected: nv_replace_lbody/5 had an extra clause from nv_replace_body/5.
> % 8/5/02 - G. Penn
> 
> % Bug corrected: nv_replace_ldesc/5 was being used both to transform LDescs into narrow LDescs,
> %  and to transform LDescs into Descs for display.  Added nv_lreplace_ldesc/5 to handle the
> %  former, and d_query_goal_args/4 as a version of d_add_to_list_fresh/3 that also replaces
> %  narrow variables (previously, d_query_goal0/6  was skipping narrow var replacement on lcomp/4
> %  clauses).
> % 8/5/02 - G. Penn
> 
> % Bug corrected: nv_lreplace_ldescs/5 was missing.
> % 8/6/02 - G. Penn
> 
> % Bug corrected: added current_predicate/2 guard for lrule/4 to d_close_emptys/3.
> % 8/7/02 - G. Penn
> 
> % Bug corrected: removed +1 offset in d_ask/3 for which line to highlight (the discrepancy
> %  was apparently resolved when SICS ported Milner's code).
> % 8/7/02 - G. Penn
> 
> % Extended debugger to multiple input files by wrapping filename with line number.
> % 8/14/02 - G. Penn
> 
> % Bug corrected: abolish_lpreds/0 did not abolish lsemantics/2, misspelled lclosedrule/7,
> %  and unnecessarily abolished lshallow/4.  Added current_predicate/2 guards for 'l--->'/3,
> %  lmacro/2, and lsemantics/2.
> % 8/15/02 - G. Penn
> 
> % Bug corrected: analogous changes made to d_query/1 and d_query_cond/9 as with query_goal/1
> %  and query_cond/9 in ALE.
> % 8/15/02 - G. Penn
> 
> % Added support for constraint debugging.
> % 8/15/02 - G. Penn
> 
> % Bug corrected: RHS parsing in label_term/5 was missing parentheses around goal/2 operator.
> % 9/4/02 - G. Penn
> 
> % Call expand_term/2 before labelling to catch possible term_expansion/2 hooks. Removed label_term/5 from recursive loop,
> %  made multifile, and removed input stream argument.  Now people can label other terms using this as a hook.
> % 9/5/02 - G. Penn
> 
> % lcons/3 now has a real goal in its last argument (typically d_query(LabelledGoal)), and an extra argument for the FS
> %  that the labelled constraint is enforced upon.  This will allow us to sneak in uninterpreted code if we need to.
> % 9/5/02 - G. Penn
> 
> % Bug corrected: Added current_predicate/2 guard for lcons/4 to dct/4 compiler spec.
> % 9/5/02 - G. Penn
> 
> % Now use ale_debugging/0 to allow ALE term_expansion to add ale_debug/1 clauses as files are being consulted - this allows
> %  includes and directives within source files to load other files.
> % 9/19/02 - G. Penn
> 
> % Bug corrected: empty_cat/6 failure clause added by d_close_emptys_rules/0 had extra inequation argument.
> % 9/21/02 - G. Penn
> 
> % Augmented d_blocked/1 with Line info and modified d_blocked/2 and d_unblocked/1 to be silent during skipping and leaping.
> % 9/21/02 - G. Penn
> 
> % Added d_skip_level/1 resets to drec/4 and dgen/[1,2,3], as well as residue handling, on analogy to ALE predicates.
> % 9/21/02 - G. Penn
> 
> % Moved type/1 checking for ltype/2 to label_items phase - cuts down on interpreted sub/2 calls.
> % 9/26/02 - G. Penn
> 
> % Added prolog/2 goal.
> % 9/29/02 - G. Penn
> 
> % Bug corrected: assoc. lists weren't initialised in drec/1, dgen/1, and dgen/2.
> % 9/29/02 - G. Penn
> 
> % debug_lex/0 flag added.  compile_lex_rules/0 and compile_lex/0 added to dcompile_gram/0 compiler chain.
> % 9/29/02 - G. Penn
> 
> % Bug corrected: changed consult/1 call to reconsult/1 in dcompile_gram/0.
> % 9/29/02 - G. Penn
> 
> % Updated extensionalise/2 and extensionalise_list/1 calls.
> % 10/17/02 - G. Penn
> 
> % Bug corrected: forgot to update ext_act/2 call in d_query_goal/6.
> % 11/2/02 - G. Penn
> 
> % Changed lcons/4 to lcons/5 - added label for first line of constraint for
> %  command-line spypoint commands.
> % 6/5/03 - G. Penn
> 
> % Added dspy/1, dspy_cons/1, dspy_macro/1, dspy_fun/1, dspy_lex/1, dspy_lr/1,
> %  and dspy_rule/1 and dnospy/1 etc. to (re)set spypoints from the command-line.
> %  Empty categories cannot be spied on yet because they are anonymous.
> % 6/5/03 - G. Penn
> 
> % Bug corrected: fun_exp/3 should be fun_exp/2, and fun_spec/3 call should be
> %  inside the functional description port.
> % 6/6/03 - G. Penn
> 
> % Changed lmacro/2 to lmacro/3 - added label for first line of description for
> %  command-line spypoint commands.
> % 6/6/03 - G. Penn
> 
> % Added d_meta_interp/3 to abstract failure exception handling and call_det/2
> %  to eliminate redo ports when backtracking on deterministic exits.  Also added
> %  retry option to exit and redo ports, and changed d_exit_redo/2 to d_exit_redo/3
> %  to carry deterministic flag for printing '?' at exit ports.
> % 6/6/03 - G. Penn
> 
> % Added unknown word check and solution/1 indexing to drec/4.
> % 6/23/03 - G. Penn
> 
> % Updated dgen/1, dgen/2, drec/1 and drec/4 to use pp_fs_res/3 and exception handler.
> % 8/5/03 - G. Penn
> 
> % Bug corrected: leaping was both the result of 'l' and spy commands.  In the latter case,
> %  we wanted leap mode to persist, but in the former, we did not.  Now, leaping mode
> %  never persists, and is not set by the dspy commands.  reset_d_mode/0 restores creeping.
> % 9/28/03 - G. Penn
> 
> % Updated debugger to run-time ct/3.
> % 9/28/03 - G. Penn
> 
> % Added announcement to label_items/0 phase and added extra spacing to undefined messages
> %  to make errors more readable.
> % 10/9/03 - G. Penn
> 
> % Ported to new data structure.
> % 7/20/06 - G. Penn
> 
> % Bug corrected: d_match_list_rest/9 was not calling arg/3 to instantiate tail FS.
> % 5/13/07 - G. Penn
> 
> % Bug corrected: d_add_dtrs_rest/8 on final lcats/1 was missing an argument in its call to
> %  d_match_list_rest/9.
> % 5/13/07 - G. Penn
> 
> % Added chart_init_hook/2 and trap for edgelimit_exceeded/1 exception on d_build/3 call
> %  in drec/3.
> % 5/13/07 - G. Penn
> 
> % Bug corrected: dskip/1 was missing most of the ports that dleash/1 had.
> % 6/2/07 - G. Penn
> 
> % Added support for forall/2 rules.
> % 6/3/07 - G. Penn
> 
> % Bug corrected: pretty-printing on dquery/1 was out of date.
> % 1/26/09 - G. Penn
> 
> % add graphical variable watcher
> % debug unification and subsumption
> % might want to number clauses of relations and functional desc's for
> %  printing during trace.
> % on-demand inequation checking and extensionality enforcement at ports.
> % flags to indicate automatic ineq. checking and extensionality enforcement
> % put Locs on d_solve/4
> % leap by name of rule, lex entry etc.
> % add names to empty cat's
> % have options to print settings and restore defaults on dskipping and 
> %  leashing
> % display stack trace.
> 
> % RCS banners
> % $Id$
> %
> % $Log$
> 
> :- use_module(library(lists)).
> :- use_module(library(assoc)).
> 
> :- dynamic ale_noemacs/0.
> 
> :- op(1100,fx,dquery).
> :- op(1100,fx,dgen).
> :- op(1100,fx,drec).
> 
> %:- ['load_sicstus_debug'].
> %:- load('source-debug').
> %:- load('emacs-interface').
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % emacs/0, noemacs/0:  enable/disable emacs-lisp control strings
> emacs :-
>   retractall(ale_noemacs),
>   nl,write('emacs interface enabled'),
>   nl.
> noemacs :-
>   assert(ale_noemacs),
>   nl,write('emacs interface disabled'),
>   nl.
> 
> emacs_format(Stream,Message,Vars) :-
>   ale_noemacs -> true ; format(Stream,Message,Vars).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % dcompile_gram/1: compile file for debugging (currently must be all in one
> %  file, except prolog hooks, which must be separate file(s))
> 
> dcompile_gram(File) :-
> %  retractall(ale_break(_)), % --- moved to abolish_lpreds
> %  retractall(ale_debugging),
> %  retractall(ale_debug(_)),
> %  retractall(ale_breakable_lines(_)),
>   abolish_preds,
> %  abolish_compiled_preds, % need to do this in case compile_gram/1 was
>   abolish_lpreds,          %  called earlier in this session.
>   assert(ale_debugging),
>   reconsult(File),
> %  ( is_list(File) -> ( member(F,File), absolute_file_name(F,AbsFile),     % --- tabulated by ALE term_expansion/2 hook
> %		       assertz(ale_debug(AbsFile)), consult(AbsFile), fail
> %                     ; true
> %		     )
> %  ; absolute_file_name(File,AbsFile),assertz(ale_debug(AbsFile)),consult(AbsFile)
> %  ),
>   retractall(ale_debugging),
>   pcompile_gram1,
>   label_items,
>   dcompile_cons,
>   pcompile_gram2,
>   compile_lex_rules,
>   set_d_mode(OldMode,skip([])), % skip all ports during lexicon compilation
>   reset_d_skip_level,
>   compile_lex,
>   set_d_mode(OldMode),  % restore former mode
>   retractall(d_skip_level(_)),
>   \+ \+ d_close_emptys_rules.
> 
> :- multifile alec_catch_hook/2, if_b/2.
> alec_catch_hook(dct,[(ct(Type,FS,Types) :-
> 		        dct(Type,FS,Types)),end_of_file]) :-
>   dct_constrained_assert.
> 
> dct_constrained_assert :-
>   current_predicate(lcons,lcons(_,_,_,_,_)),
>   lcons(Type,_,_,_,_),
>   assert(constrained(Type)),
>   fail.
> dct_constrained_assert.
>   
> dct(Type,FS,Types) :-
>   lcons(Type,_,LabelledCons,FS,Goal),  % typically, Goal is a labelled goal embedded in a d_query/1 call
>   deref(FS,TFS,FSType,AttPos),
>   d_add_to(LabelledCons,FS,FSType,TFS,AttPos,bot,cons(Type)),
>   call(Goal),
>   enforce_constraints(Types,FS).
> 
> dcompile_cons :-
>   touch('.alec_throw'),
>   absolute_file_name('.alec_throw',AbsFileName),
>   retractall(ale_compiling(_)),
>   assert(ale_compiling(AbsFileName)),
>   dcompile_cons_act,
>   retract(ale_compiling(_)).
> 
> dcompile_cons_act :-
>   alec_announce('Compiling type constraints...'),
>   abolish((ct)/3),retractall(constrained(_)),
>   (current_predicate(lcons,lcons(_,_,_,_,_)) ->
>             [bot,has,constraints] if_error lcons(bot,_,_,_,_),
>             [multiple,constraint,declarations,for,CType] if_error
>                  (bagof(CT,CLabel^LCons^Goal^FS^(lcons(CT,CLabel,LCons,FS,Goal)),CTypes),
>                   duplicated(CType,CTypes)),
>             [constraint,declaration,given,for,atom] if_error lcons((a_ _),_,_,_,_),
>       assert(alec(dct)),
>       \+ \+ compile('.alec_throw')
>   ; ([no,constraints,found] if_warning true)
>   ),
>   ( current_predicate(compile_cons_hook,compile_cons_hook) -> call_all(compile_cons_hook) ; true).
> 	
> % pcompile_gram: compile type logic as before
> pcompile_gram1 :-
>   compile_sig,
>   compile_fun.
> pcompile_gram2 :-
>   compile_logic,
>   compile_subsume,
>   compile_dcs.
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % drec/1:  Interactive parser
> drec(Words) :-
>   nl, write('STRING: '),
>   nl, number_display(Words,0),
>   ttynl,
>   \+ \+ on_exception(ale(Exception),
> 		     (drec(Words,FS,Residue),
> 		      ((current_predicate(portray_cat,portray_cat(_,_,_,_)),
> 			portray_cat(Words,bot,FS,Residue)) -> true
>                       ; nl, write('CATEGORY: '),nl, ttyflush,
> 			pp_fs_res(FS,Residue), nl
> 		      ),
> 		      query_proceed),
> 		     alex(Exception)).
> 
> drec(Ws,FS,Residue) :-
>   clear,
>   reset_d_mode,
>   reset_d_skip_level,
>   announce_parse_begin(Ws),
>   assert(parsing(Ws)),
>   ( current_predicate(lex,lex(_,_))
>   -> reverse_count_lex_check(Ws,[],WsRev,0,Length),
>      rec_chart_init(Length,Chart),
>      on_exception(Exception,d_build(WsRev,Length,Chart),build_exn(Exception)),
>      retract(to_rebuild(Index)),
>      call_residue(clause(edge(Index,0,Length,FS,_,_),true),Residue),
>      assert(solution(Index))
>   ; raise_exception(ale(no_lex))
>   ).
> 
> :- dynamic debug_lex/0.
> dlex :-
>   assert(debug_lex),
>   nl, write('debugger will step through lexical rules/entries'),
>   nl.
> 
> nodlex :-
>   retractall(debug_lex),
>   nl, write('debugger will not step through lexical rules/entries'),
>   nl.
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % dquery/1:  Interactive definite clause resolution
> dquery(GoalDesc):-
>   reset_d_mode,
>   reset_d_skip_level,
>   \+ \+
>   (nl, label_query(GoalDesc,LabelledGoalDesc),
>    empty_assoc(AssocIn),
>    call_residue((d_query_goal_cut(LabelledGoalDesc,Args,[],Goal,Zip),
> 		 Zip = []), % Args isn't well-formed until we instantiate this.
> 		Residue),
>    \+ \+ (((current_predicate(portray_ale_goal,portray_ale_goal(_,_)),
> 	    portray_ale_goal(Goal,Residue)) -> true
> 	  ; build_iqs_restore_atts(Residue,Iqs,FSResidue),
>  	    (ale_flag(residue,show) -> residue_args(Residue,ResArgs,Args) ; ResArgs = Args),
> 	    duplicates_list(ResArgs,AssocIn,DupsMid,AssocIn,VisMid,0,NumMid),
>   	    duplicates_iqs(Iqs,DupsMid,DupsMid2,VisMid,_,NumMid,_),
> 	    pp_goal(Goal,DupsMid2,DupsMid3,AssocIn,VisMid2,0,AssocIn,HDMid),
> 	    nl,nl,
> 	    pp_iqs(Iqs,DupsMid3,DupsOut,VisMid2,VisOut,0,HDMid,HDOut),
> 	    ((ale_flag(residue,show),FSResidue \== [])
> 	     -> nl,nl, write('Residue:'), pp_residue(Residue,DupsOut,_,VisOut,_,HDOut,_)
> 	     ; true), nl
> 	   ),
> 	 query_proceed)
>    ).
> 
> d_query(LabelledGoalDesc) :-
>   d_query_goal(LabelledGoalDesc,_,_,_,[]).
>   % instantiating Zip now guarantees no Arg suspensions.
> 
> d_query_goal_cut(LabelledGoalDesc,Args,ArgsRest,Goal,Zip) :-
>   on_exception(cut,d_query_goal(LabelledGoalDesc,Args,ArgsRest,Goal,Zip),
>                    (retract(d_skip_level(Skip))
> 		   -> OldSkip is Skip - 1,
> 		      asserta(d_skip_level(OldSkip)),
> 		      fail)).
> 
> d_query_goal(LabelledGoalDesc,Args,ArgsRest,Goal,Zip) :-
>   empty_assoc(NVs),
>   d_query_goal0(LabelledGoalDesc,Args,ArgsRest,Goal,NVs,Zip).
> 
> d_build([W|Ws],Right,Chart):-
>   RightMinus1 is Right - 1,
>   ( (debug_lex -> d_lex(W,RightMinus1,Right,Chart)
>     ; lex(W,FS),
>       d_add_edge(RightMinus1,Right,FS,[],lexicon,Chart)
>     )
>   ; (RightMinus1 =:= 0
>      -> true
>       ; rebuild_edges(Edges),
>         arg(RightMinus1,Chart,Edges),
>         d_build(Ws,RightMinus1,Chart)
>     )
>   ).
> d_build([],_,_).
> 
> d_add_to(LabelledDesc,FS,Loc) :-
>   deref(FS,TFS,Type,AttPos),
>   d_add_to(LabelledDesc,FS,Type,TFS,AttPos,bot,Loc).
> 	
> :- discontiguous d_add_to/7.
> d_add_to(lvar(X,XName,XLine),FS,_Type,_TFS,_AttPos,VType,Loc):-
>   !,    % also instantiates variable first arguments
>   d_meta_interp(unify(Loc,XName,FS,X),XLine,d_add_to_lvar(X,FS,VType,Loc)).
>   d_add_to_lvar(X,FS,VType,Loc) :-
>     X = FS, deref(FS,TFS,Type,AttPos),
>     d_meta_interp(type(Loc,VType,FS),[],add_to_type(VType,Type,TFS,AttPos)).
> d_add_to(lelist(LBrackLine),FS,Type,TFS,AttPos,VType,Loc):-
>   !, d_add_to(ltype(e_list,LBrackLine),FS,Type,TFS,AttPos,VType,Loc).
> d_add_to(lnelist(HeadLine,TailLine,LH,LT),FS,Type,TFS,AttPos,VType,Loc):-
>   !, d_add_to((lfeat(hd,HeadLine):LH,lfeat(tl,TailLine):LT),FS,Type,TFS,AttPos,VType,Loc).
> d_add_to(lpatheq(Path1,Path2,OpLine,LP1,LP2),FS,Type,TFS,AttPos,VType,Loc):-
>   !, d_meta_interp(patheq(Loc,Path1,Path2,FS),OpLine,
> 		   d_add_to_lpatheq(LP1,Path1,FS,Type,TFS,AttPos,VType,LP2,Path2)).
>   d_add_to_lpatheq(LP1,Path1,FS,Type,TFS,AttPos,VType,LP2,Path2) :-
>     d_pathval(LP1,Path1,FS,AttPos,Type,TFS,FSAtPath1,VType),
>     deref(FS,TFSMid,TypeMid,AttPosMid),
>     d_pathval(LP2,Path2,FS,AttPosMid,TypeMid,TFSMid,FSAtPath2,VType),
>     FSAtPath1=FSAtPath2.   % call_u(TypeAtPath1,TypeAtPath2,TFSAtPath1,TFSAtPath2,FSAtPath1,FSAtPath2),
> d_add_to(lineq(OpLine,LabelledDesc),FS,Type,TFS,AttPos,VType,Loc):-
>   !, d_meta_interp(type(Loc,VType,FS),[],add_to_type(VType,Type,TFS,AttPos)),
>   d_meta_interp(ineq_add(Loc,FS),OpLine,
> 		d_add_to_lineq(LabelledDesc,FS)).
>   d_add_to_lineq(LabelledDesc,FS) :-
>     d_add_to(LabelledDesc,FS2,ineq),
>     ineq(FS,FS2).
> d_add_to(lfeat(Feat,FLine):LabelledDesc,FS,Type,TFS,AttPos,VType,Loc):-
>   !,
>   ( var(Feat) -> strip_labels(LabelledDesc,Desc),
>                  raise_exception(ale(feat_notatom(Feat,Feat:Desc)))
>   ; approp(Feat,_,_) -> true
>   ; raise_exception(ale(undef_feat(Feat)))
>   ),
>   d_meta_interp(featval(Loc,Feat,FS),FLine,
> 		d_add_to_lfeat(Feat,FS,Type,TFS,AttPos,VType,LabelledDesc)).
>   d_add_to_lfeat(Feat,FS,Type,TFS,AttPos,VType,LabelledDesc) :-
>     featval(Feat,FS,Type,TFS,AttPos,FSatFeat,VType,FVType),
>     deref(FSatFeat,TFSatFeat,TypeatFeat,AttPosFeat),
>     d_add_to(LabelledDesc,FSatFeat,TypeatFeat,TFSatFeat,AttPosFeat,FVType,feat(Feat)).
> d_add_to((LabelledDesc1,LabelledDesc2),FS,Type,TFS,AttPos,VType,Loc):-
>   !, d_add_to(LabelledDesc1,FS,Type,TFS,AttPos,VType,Loc),
>   deref(FS,TFS2,Type2,AttPos2),
>   d_add_to(LabelledDesc2,FS,Type2,TFS2,AttPos2,VType,Loc).
> d_add_to((LabelledDesc1;LabelledDesc2),FS,Type,TFS,AttPos,VType,Loc):-
>   !, 
>   ( d_add_to(LabelledDesc1,FS,Type,TFS,AttPos,VType,Loc)
>   ; d_add_to(LabelledDesc2,FS,Type,TFS,AttPos,VType,Loc)
>   ).
> d_add_to(lmac(MacroName,OpLine),FS,Type,TFS,AttPos,VType,Loc):-
>   !, d_meta_interp(macro(MacroName,FS),OpLine,d_add_to_lmac(MacroName,FS,Type,TFS,AttPos,VType,Loc)).
>   d_add_to_lmac(MacroName,FS,Type,TFS,AttPos,VType,Loc) :-
>     ( (current_predicate(lmacro,lmacro(_,_,_)),
>        lmacro(MacroName,_,LabelledMacroDesc)) -> d_add_to(LabelledMacroDesc,FS,Type,TFS,AttPos,VType,Loc)
>     ; raise_exception(ale(macro_noadd(MacroName,FS)))
>     ).
> d_add_to(ltype(Type,TLine),FS,FSType,TFS,AttPos,VType,Loc):-
>   !,
>   ( sub_type(Type,VType) -> true
>   ; unify_type(Type,VType,AddType),
>     d_meta_interp(type(Loc,AddType,FS),TLine,add_to_type(AddType,FSType,TFS,AttPos))
>   ).
> d_add_to(latom(Atom,ALine),FS,Type,TFS,AttPos,VType,Loc):-
>   !,
>   ( sub_type((a_ Atom),VType) -> true
>   ; unify_type((a_ Atom),VType,AddType), AddType = (a_ AddAtom),
>     d_meta_interp(atom(Loc,AddAtom,FS),ALine,add_to_type(AddType,Type,TFS,AttPos))
>   ).
> d_add_to(lfun(lcomp(Functor,FunArity,FunLine,LDList)),FS,Type,TFS,AttPos,VType,Loc) :-
>   !, d_meta_interp(fun(Functor,FunArity,FS),FunLine,
> 		   d_add_to_lfun(Functor,FunArity,LDList,FS,Type,TFS,AttPos,VType,Loc)).
>   d_add_to_lfun(Functor,FunArity,LDList,FS,Type,TFS,AttPos,VType,Loc) :-
>     clause(fun_spec(Functor,FunArity,ResArg),true),
>     RelArity is FunArity + 1,
>     PreLen is ResArg - 1, PostLen is FunArity - ResArg + 1,
>     length(PreArgs,PreLen), length(PostArgs,PostLen),
>     append(PreArgs,PostArgs,FunArgs),
>     append(PreArgs,[FS|PostArgs],RelArgs),
>     d_meta_interp(type(Loc,VType,FS),[],add_to_type(VType,Type,TFS,AttPos)),
>     d_add_to_list(LDList,FunArgs,1),
>     d_solve_goal_cut(Functor,RelArity,RelArgs).
>   d_add_to_lfun(Functor,FunArity,LDList,FS,Type,TFS,AttPos,VType,Loc) :-
>     clause(fun_spec(Functor,FunArity,_ResArg),true),
>     clause(fun_exp(Functor,FunArity),true),
>     d_meta_interp(type(Loc,VType,FS),[],add_to_type(VType,Type,TFS,AttPos)),    
>     d_fsolve(Functor,FunArity,LDList,FS,Loc).
> 
> d_pathval([],_,FS,_,_,_,FS,_).
> d_pathval([lfeat(Feat,FLine)|LPath],[_|Path],FS,AttPos,Type,TFS,FSOut,VType) :-
>   d_meta_interp(featval(path,Feat,FS),FLine,
> 		d_pathval_act(Feat,FS,AttPos,Type,TFS,LPath,Path,FSOut,VType)).
>   d_pathval_act(Feat,FS,AttPos,Type,TFS,LPath,Path,FSOut,VType) :-
>     featval(Feat,FS,Type,TFS,AttPos,FSatFeat,VType,FVType),
>     deref(FSatFeat,TFSatFeat,TypeatFeat,AttPosFeat),
>     d_pathval(LPath,Path,FSatFeat,AttPosFeat,TypeatFeat,TFSatFeat,FSOut,FVType).
> 
> 
> d_lex(Word,Left,Right,Chart) :-
>   current_predicate('l--->','l--->'(_,_,_,_)),
>   'l--->'(WordStart,WordLine,LabelledDesc,LabelledGoal),
>   d_meta_interp(lex(Word,WordStart),WordLine,d_lex_act(LabelledDesc,LabelledGoal,WordStart,FS,Word)),
>   d_add_edge(Left,Right,FS,[],lexicon,Chart).
>   d_lex_act(LabelledDesc,LabelledGoal,WordStart,FS,Word) :-
>     d_add_to(LabelledDesc,FSStart,lex),
>     curr_lex_rule_depth(Max),
>     d_lex_close(0,Max,WordStart,FSStart,LabelledGoal,Word,FS),
>     d_apply_forall_lex(Word,FS).
> 
> d_apply_forall_lex(Word,FS) :-
>   ( current_predicate(lforall_lex,lforall_lex(_,_,_))
>   -> d_meta_interp(forall_lexes(Word,FS),[],d_apply_forall_lexes(Word,FS))
>   ; true
>   ).
> 
> d_apply_forall_lexes(_,_) :-
>   findall(Name,lforall_lex(Name,_,_),Names),
>   has_duplicates(Names),
>   append(_,[Name|Rest],Names), member_eq(Name,Rest),
>   raise_exception(ale(forall_lex_dup(Name))).
> d_apply_forall_lexes(Word,FS) :-
>   findall(lforall_lex(Name,ForallLine,LDoRule),
> 	  lforall_lex(Name,ForallLine,LDoRule),LFALexes),
>   d_apply_forall_lexes_act(LFALexes,Word,FS).
> 
> d_apply_forall_lexes_act([],_,_).
> d_apply_forall_lexes_act([lforall_lex(Name,ForallLine,LDoRule)|LFALexes],Word,FS) :-
>   d_meta_interp(forall_lex(Name,Word,FS),ForallLine,
> 		d_apply_forall_lex0(Word,FS,LDoRule)),
>   d_apply_forall_lexes_act(LFALexes,Word,FS).
> 
> d_apply_forall_lex0(Word,FS,ldo_lex(Word0,LexLabel,Cond,LabelledDoBody)) :-
>   d_meta_interp(match_forall_lex_name(Word0,FS,Word),LexLabel,(Word = Word0)),
>   d_meta_interp(match_forall_lex(Word,FS),LexLabel,
> 		d_query(lwhen(LexLabel,(FS=Cond),LabelledDoBody))).
> 	
> d_lex_close(_,_,Word,FS,LabelledGoal,Word,FS) :-
>   d_query(LabelledGoal).
> d_lex_close(N,Max,WordIn,FSIn,LGoalIn,WordOut,FSOut):-
>   current_predicate(llr,llr(_,_,_)),
>   N < Max,
>   d_lex_rule(WordIn,FSIn,LGoalIn,WordMid,FSMid,LGoalMid),
>   NPlus1 is N + 1,
>   d_lex_close(NPlus1,Max,WordMid,FSMid,LGoalMid,WordOut,FSOut).
> 
> d_lex_rule(WordIn,FSIn,LGoalIn,WordOut,FSOut,LGoalOut) :-
>   llr(RuleName,InLine,llrbody(LNMBody,LMorphs)),
>   d_meta_interp(lr(RuleName,WordIn,FSIn),InLine,
>                 d_lex_rule_act(LNMBody,FSIn,LMorphs,WordIn,LGoalIn,WordOut,FSOut,LGoalOut)).
>   d_lex_rule_act(LNMBody,FSIn,LMorphs,WordIn,LGoalIn,WordOut,FSOut,LGoalOut) :-
>     ( LNMBody = llrmap(LDIn,LGoalIn,LDOut,LGoalOut) -> LabelledCond = ltrue
>     ;  LNMBody = lif(llrmap(LDIn,LGoalIn,LDOut,LGoalOut),LabelledCond)
>     ),
>     d_add_to(LDIn,FSIn,lrin),
>     d_query(LabelledCond),
>     d_add_to(LDOut,FSOut,lrout),
>     d_morphs(LMorphs,WordIn,WordOut).
> 
> d_morphs(lmorph_seq(LMorph,LMorphs),WordIn,WordOut) :-
>   !,(d_morph(LMorph,WordIn,WordOut) ->
>        true
>     ; d_morphs(LMorphs,WordIn,WordOut)).
> d_morphs(LMorph,WordIn,WordOut) :-
>   d_morph(LMorph,WordIn,WordOut).
> 
> :- discontiguous d_morph/3.
> d_morph(lmorph_cond(WhenLine,lmorph(OpLine,StrIn,StrOut),Cond),WordIn,WordOut) :-
>   !, d_meta_interp(morph_input(WordIn,WordOut),OpLine,
> 		   d_morph_lmorph_cond(WordIn,StrIn,WhenLine,Cond,WordOut,StrOut)).
>   d_morph_lmorph_cond(WordIn,StrIn,WhenLine,Cond,WordOut,StrOut) :-
>     name(WordIn,CodesIn),
>     make_char_list(CodesIn,CharsIn),
>     morph_pattern(StrIn,CharsIn),
>     d_meta_interp(lrwhen,WhenLine,d_query_goal0_lprolog(Cond)),
>     morph_pattern(StrOut,CharsOut),
>     make_char_list(CodesOut,CharsOut),
>     name(WordOut,CodesOut).
>     d_query_goal0_lprolog(Cond) :-
>       ( d_mode(creep) -> (trace ; (notrace,fail))
>       ; true  % this must be inlined, or else user sees exit port.
>       ),
>       call(Cond),
>       switch_off_prolog_debugger.
> d_morph(lmorph(OpLine,StrIn,StrOut),WordIn,WordOut) :-
>   d_meta_interp(morph_input(WordIn,WordOut),OpLine,d_morph_lmorph(WordIn,StrIn,WordOut,StrOut)).
>   d_morph_lmorph(WordIn,StrIn,WordOut,StrOut) :-
>     name(WordIn,CodesIn),
>     make_char_list(CodesIn,CharsIn),
>     morph_pattern(StrIn,CharsIn),
>     morph_pattern(StrOut,CharsOut),
>     make_char_list(CodesOut,CharsOut),
>     name(WordOut,CodesOut).
> 
> :- discontiguous d_query_goal0/6.
> d_query_goal0((LGoal1,LGoal2),Args,ArgsRest,(G1,G2),NVs,Zip) :-
>   !,d_query_goal0(LGoal1,Args,ArgsMid,G1,NVs,Zip),
>   d_query_goal0(LGoal2,ArgsMid,ArgsRest,G2,NVs,Zip).
> d_query_goal0((LGoal1;LGoal2),Args,ArgsRest,(G1;G2),NVs,Zip) :-
>   !,( d_query_goal0(LGoal1,Args,ArgsMid,G1,NVs,Zip),
>       nv_replace_lbody(LGoal2,G2,ArgsMid,ArgsRest,NVs)
>     ; d_query_goal0(LGoal2,ArgsMid,ArgsRest,G2,NVs,Zip),
>       nv_replace_lbody(LGoal1,G1,Args,ArgsMid,NVs)
>     ).
> d_query_goal0(lneg(NLine,LGoal),Args,ArgsRest,(\+ G1),NVs,_) :-
>   !,d_meta_interp(neg,NLine,d_query_goal0_lneg(LGoal,NVs,G1,Args,ArgsRest)).
>   d_query_goal0_lneg(LGoal,NVs,G1,Args,ArgsRest) :-
>     \+ d_query_goal0(LGoal,_,_,_,NVs,_),
>     nv_replace_lbody(LGoal,G1,Args,ArgsRest,NVs).
> d_query_goal0(lexteq(OpLine,LD1,LD2),[FS1,FS2|ArgsMid],ArgsRest,
> 	      (FS1 =@ FS2),NVs,_) :-
>   !,
> %  write(user_error,'call exteq:'),nl(user_error),flush_output(user_error),
> %  (
>   d_meta_interp(exteq,OpLine,
> 		d_query_goal0_lexteq(LD1,ArgsMid,NVs,LD2,ArgsRest,FS1,FS2)).
> %  write(user_error,'exit exteq:'),nl(user_error),flush_output(user_error)
> %  ; write(user_error,'fail exteq:'),nl(user_error),flush_output(user_error),
> %    fail  % DEBUG
> %  ),
> %  d_skip_level(S), write(user_error,'skip '),write(user_error,S), %DEBUG
> %  nl(user_error), flush_output(user_error).
>   d_query_goal0_lexteq(LD1,ArgsMid,NVs,LD2,ArgsRest,FS1,FS2) :-
>     nv_lreplace_ldesc(LD1,NLD1,ArgsMid,ArgsMid2,NVs),
>     d_add_to(NLD1,FS1,left),
>     nv_lreplace_ldesc(LD2,NLD2,ArgsMid2,ArgsRest,NVs),
>     d_add_to(NLD2,FS2,right),
>     FS1 == FS2.
> d_query_goal0(lunify(OpLine,LD1,LD2),[FS,FS|ArgsMid],ArgsRest,
> 	      (FS = FS),NVs,_) :-
>   !,d_meta_interp(eq,OpLine,
> 		  d_query_goal0_lunify(LD1,ArgsMid,NVs,LD2,ArgsRest,FS)).
>   d_query_goal0_lunify(LD1,ArgsMid,NVs,LD2,ArgsRest,FS) :-
>     nv_lreplace_ldesc(LD1,NLD1,ArgsMid,ArgsMid2,NVs),
>     d_add_to(NLD1,FS,left),
>     nv_lreplace_ldesc(LD2,NLD2,ArgsMid2,ArgsRest,NVs),
>     d_add_to(NLD2,FS,right).
> d_query_goal0(lwhen(OpLine,Cond,LBody),Args,ArgsRest,when(NCond,NBody),NVs,Zip) :-
>   !,d_meta_interp(when,OpLine,
> 		  d_query_goal0_lwhen(LBody,OpLine,Cond,NCond,Args,ArgsRest,NBody,
> 				      NVs,Zip)).
>   d_query_goal0_lwhen(LBody,OpLine,Cond,NCond,Args,ArgsRest,NBody,NVs,Zip) :-
>     d_blocked(LBody,OpLine),
>     d_query_cond(Cond,NCond,LBody,Args,ArgsRest,NBody,NVs,Zip,_).
> d_query_goal0(ltrue,Args,Args,true,_,_) :-
>   !.
> d_query_goal0(lfail,_,_,_,_,_) :-
>   !,fail.
> d_query_goal0(lcut,Args,Args,!,_,_) :-
>   !,
>   ( true
>   ; raise_exception(cut)).
> d_query_goal0(lshallow(ArrowLine,LIfGoal,LThenGoal,LElseGoal),Args,ArgsRest,
> 	      (G1 -> G2 ; G3),NVs,Zip) :-
>   !,d_meta_interp(shallow,ArrowLine,
>                   d_query_goal0_lshallow(LIfGoal,Args,G1,NVs,Zip,LThenGoal,G2,
> 					 LElseGoal,G3,ArgsRest)).
>   d_query_goal0_lshallow(LIfGoal,Args,G1,NVs,Zip,LThenGoal,G2,LElseGoal,G3,ArgsRest) :-
>     (d_query_goal0(LIfGoal,Args,ArgsMid,G1,NVs,Zip)
>     -> d_query_goal0(LThenGoal,ArgsMid,ArgsMid2,G2,NVs,Zip),
>        nv_replace_lbody(LElseGoal,G3,ArgsMid2,ArgsRest,NVs)
>     ; d_query_goal0(LElseGoal,ArgsMid2,ArgsRest,G3,NVs,Zip),
>       nv_replace_lbody(LIfGoal,G1,Args,ArgsMid,NVs),
>       nv_replace_lbody(LThenGoal,G2,ArgsMid,ArgsMid2,NVs)
>     ).
> d_query_goal0(lprolog(OpLine,PGoal),Args,Args,prolog(PGoal),_NVs,_) :-
>   !,
>   d_meta_interp(prolog(PGoal),OpLine,d_query_goal0_lprolog(PGoal)).
> d_query_goal0(lprolog(OpLine,NVs,PGoal),Args,Args,prolog(NVs,PGoal),NVs,_) :-
>   !,
>   d_meta_interp(prolog2(PGoal),OpLine,d_query_goal0_lprolog(PGoal)).
> d_query_goal0(lcomp(Functor,Arity,FunLine,LabelledDescList),Args,ArgsRest,Goal,NVs,_) :-
>   d_meta_interp(comp(Functor,Arity),FunLine,
>                 d_query_goal0_lcomp(LabelledDescList,NVs,Args,ArgsRest,Goal,Functor,Arity)).
>   d_query_goal0_lcomp(LabelledDescList,NVs,Args,ArgsRest,Goal,Functor,Arity) :-
>     d_query_goal_args(LabelledDescList,RelArgs,NVs,1),
>     append(RelArgs,ArgsRest,Args),
>     Goal =.. [Functor|RelArgs],
>     d_solve_goal_cut(Functor,Arity,RelArgs).
> 
> d_query_cond(X^(Cond),Fresh^(NCond),LBody,Args,ArgsRest,NBody,NVs,Zip,FreshNVs) :-
>   when(nonvar(FreshNVs),get_assoc(X,FreshNVs,seen(Fresh))),
>   put_assoc(X,NVs,unseen,NVsMid),
>   d_query_cond(Cond,NCond,LBody,Args,ArgsRest,NBody,NVsMid,Zip,FreshNVs).
> d_query_cond(Cond,NCond,LBody,Args,ArgsRest,NBody,NVs,Zip,FreshNVs) :-
>   var(Zip),
>   !, when(nonvar(FreshNVs),nv_replace_cond0(Cond,NCond,Args,ArgsMid,FreshNVs)),
>   when(nonvar(Zip),(var(FreshNVs) -> map_assoc(nv_fresh,NVs,NVsSeen),
> 		                     nv_replace_lbody(LBody,NBody,ArgsMid,ArgsRest,NVsSeen),
> 		                     FreshNVs = NVsSeen
> 		                   ; true)),
>   transform_cond(Cond,CUFCond),
>   query_cond0(CUFCond,(map_assoc(nv_fresh,NVsOut,NVsSeen),
> 		       FreshNVs = NVsSeen,
> 		       d_unblocked(LBody),
> 		       d_query_goal0(LBody,ArgsMid,ArgsRest,NBody,FreshNVs,Zip)),
> 	      NVs,NVsOut).
> d_query_cond(Cond,_,LBody,_,_,_,NVs,Zip,FreshNVs) :-
>   % nonvar(Zip) - so forget about NCond, NBody, and DtrCats-Rest
>   transform_cond(Cond,CUFCond),
>   query_cond0(CUFCond,(map_assoc(nv_fresh,NVsOut,NVsSeen),
> 		       FreshNVs = NVsSeen,
> 		       d_unblocked(LBody),
>                        d_query_goal0(LBody,_,_,_,FreshNVs,Zip)),
> 	      NVs,NVsOut).
> 
> d_solve_goal_cut(Functor,RelArity,RelArgs) :-
>   on_exception(cut,d_solve_goal(Functor,RelArity,RelArgs),
>                    (retract(d_skip_level(Skip))    % undo comp_clause/2 step
> 	           -> OldSkip is Skip - 1,
> 		      asserta(d_skip_level(OldSkip)),
> 	       fail)).
> 
> d_solve_goal(Rel,Arity,Args) :-
>   current_predicate(lif,lif(_,_)),
>   lif(lcomp(Rel,Arity,FunLine,LabelledDescs),LabelledBody),
>   d_meta_interp(comp_clause(Rel,Arity),FunLine,
>                 d_solve_goal_act(LabelledDescs,Args,LabelledBody)).
>   d_solve_goal_act(LabelledDescs,Args,LabelledBody) :-
>     d_add_to_list(LabelledDescs,Args,1),
>     d_query(LabelledBody).
> 
> d_fsolve(Rel,Arity,LArgDescs1,FS,Loc) :-
>   current_predicate('l+++>','l+++>'(_,_)),
>   d_add_to_list(LArgDescs1,Args,1),
>   'l+++>'(lcomp(Rel,Arity,FunLine,LArgDescs2),LabelledResult),
>   d_meta_interp(fun_clause(Rel,Arity),FunLine,
> 		d_fsolve_act(LArgDescs2,Args,LabelledResult,FS,Loc)).
>   d_fsolve_act(LArgDescs2,Args,LabelledResult,FS,Loc) :-
>     d_add_to_list(LArgDescs2,Args,1),
>     d_add_to(LabelledResult,FS,Loc).
> 
> d_query_goal_args([],[],_,_).
> d_query_goal_args([LD|LDList],[FS|RelArgs],NVs,N) :-
>   nv_lreplace_ldesc(LD,NLD,_,_,NVs),
>   d_add_to(NLD,FS,arg(N)),
>   NewN is N + 1,
>   d_query_goal_args(LDList,RelArgs,NVs,NewN).
> 		  
> %d_add_to_list_fresh([],[],_).
> %d_add_to_list_fresh([LDesc|LDescs],[Tag-bot|FSs],N) :-
> %  d_add_to(LDesc,Tag,bot,arg(N)),
> %  NewN is N + 1,
> %  d_add_to_list_fresh(LDescs,FSs,NewN).
> 
> d_add_to_list([],[],_).
> d_add_to_list([LDesc|LDescs],[FS|FSs],N) :-
>   deref(FS,TFS,Type,AttPos),
>   d_add_to(LDesc,FS,Type,TFS,AttPos,bot,arg(N)),
>   NewN is N + 1,
>   d_add_to_list(LDescs,FSs,NewN).
> 
> d_add_edge(Left,Right,FSOut,Dtrs,RuleName,Chart):-
>   ale_flag(subtest,off)
>   -> (edge_assert(Left,Right,FSOut,Dtrs,RuleName,N)
>      -> d_edge_announce_add(N,Left,Right,RuleName),
>         d_meta_interp(rule_close,[],d_rule(FSOut,Left,Right,N,Chart))
>      )
>    ; (subsumed(Left,Right,FSOut,Dtrs,RuleName)
>      -> fail
>       ; (edge_assert(Left,Right,FSOut,Dtrs,RuleName,N)
>         -> d_edge_announce_add(N,Left,Right,RuleName),
>            d_meta_interp(rule_close,[],d_rule(FSOut,Left,Right,N,Chart))
>         )
>      ).
> 
> d_edge_announce_add(N,Left,Right,RuleName) :-
>   format('Edge added: Number: ~w, Left: ~w, Right: ~w, Rule: ~w~n',
>          [N,Left,Right,RuleName]),
>   ttyflush.
> 
> d_edge_announce_retrieve(N,Left,Right,RuleName) :-
>   ((d_mode(creep)
>    ;d_mode(line(_))) ->
>     format('Edge retrieved: Number: ~w, Left: ~w, Right: ~w, Rule: ~w~n',
>            [N,Left,Right,RuleName]),
>     ttyflush
>   ; true).
> 
> d_rule(FS,Left,Right,N,Chart) :-
>   current_predicate(lclosedrule,lclosedrule(_,_,_,_,_,_,_,_,_)),
>   lclosedrule(RuleName,RuleLine,LabelledMother,LabelledRuleBody,Left,
>               PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest),
>   d_meta_interp(rule(RuleName),RuleLine,
>                 d_add_dtrs(LabelledRuleBody,FS,Left,Right,N,LabelledMother,
>                            RuleName,PrevDtrs,PrevDtrsRest,Chart,DtrStore,DtrStoreRest)).
> 
> d_add_dtrs((lcat(LDtr),Rest),FS,Left,Right,N,LMother,RuleName,
>            PrevDtrs,PrevDtrsMid,Chart,DtrStore,DtrStoreMid) :-
>   !,d_add_to(LDtr,FS,edge),
>   PrevDtrsMid = [N|DtrsRest], DtrStoreMid = [FS|DtrStoreRest],
>   d_add_dtrs_rest(Rest,Left,Right,LMother,PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreRest).
> d_add_dtrs((lsem_head(LDtr),Rest),FS,Left,Right,N,LMother,RuleName,
>            PrevDtrs,PrevDtrsMid,Chart,DtrStore,DtrStoreMid) :-
>   !,d_add_to(LDtr,FS,edge),
>   PrevDtrsMid = [N|DtrsRest], DtrStoreMid = [FS|DtrStoreRest],
>   d_add_dtrs_rest(Rest,Left,Right,LMother,PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreRest).
> d_add_dtrs((lcats(LDtrs),Rest),FS,Left,Right,N,LMother,RuleName,
>            PrevDtrs,PrevDtrsMid,Chart,DtrStore,DtrStoreMid) :-
>   !,d_add_to(LDtrs,FS2,dtrlist),
>   get_type(FS2,Sort),
>   ( ale_lists_defined -> clause(fcolour(hd,HdPos,_),true),
>                          clause(fcolour(tl,TlPos,_),true)
>   ; strip_labels(LDtrs,Dtrs),
>     raise_exception(cats_no_lists(RuleName,Dtrs))
>   ),
>   ((Sort == e_list) ->
>      d_add_dtrs(Rest,FS,Left,Right,N,LMother,RuleName,PrevDtrs,
>                 PrevDtrsMid,Chart,DtrStore,DtrStoreMid)
>   ; (d_match_list(Sort,FS2,HdPos,TlPos,FS,Right,N,PrevDtrsMid,DtrsRest,NextRight,Chart,DtrStoreMid,DtrStoreRest),
>      d_add_dtrs_rest(Rest,Left,NextRight,LMother,PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreRest))).
> d_add_dtrs((remainder(TlFS),LRest),FS,Left,Right,N,LMother,RuleName,PrevDtrs,PrevDtrsMid,
> 	   Chart,DtrStore,DtrStoreMid) :-
>   !, get_type(TlFS,Sort),
>   clause(fcolour(hd,HdPos,_),true),
>   clause(fcolour(tl,TlPos,_),true),
>   d_match_list(Sort,TlFS,HdPos,TlPos,FS,Right,N,PrevDtrsMid,DtrsRest,NextRight,Chart,DtrStoreMid,DtrStoreRest),
>   d_add_dtrs_rest(LRest,Left,NextRight,LMother,PrevDtrs,DtrsRest,
>                   RuleName,Chart,DtrStore,DtrStoreRest).
> d_add_dtrs((lgoal(LGoal),Rest),FS,Left,Right,N,LMother,RuleName,PrevDtrs,PrevDtrsMid,
> 	   Chart,DtrStore,DtrStoreMid):-
>   !, d_query(LGoal),
>   d_add_dtrs(Rest,FS,Left,Right,N,LMother,RuleName,PrevDtrs,
>              PrevDtrsMid,Chart,DtrStore,DtrStoreMid).
> d_add_dtrs((lsem_goal(LGoal),Rest),FS,Left,Right,N,LMother,RuleName,
>            PrevDtrs,PrevDtrsMid,Chart,DtrStore,DtrStoreMid):-
>   !, d_query(LGoal),
>   d_add_dtrs(Rest,FS,Left,Right,N,LMother,RuleName,PrevDtrs,PrevDtrsMid,Chart,DtrStore,DtrStoreMid).
> d_add_dtrs(lcat(LDtr),FS,Left,Right,N,LMother,RuleName,PrevDtrs,PrevDtrsMid,Chart,DtrStore,DtrStoreRest):-
>   !,d_add_to(LDtr,FS,edge),
>   d_add_to(LMother,FS2,mother),
>   PrevDtrsMid = [N], DtrStoreRest = [FS],
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   d_add_edge(Left,Right,FS2,PrevDtrs,RuleName,Chart).
> d_add_dtrs(lsem_head(LDtr),FS,Left,Right,N,LMother,RuleName,
>            PrevDtrs,PrevDtrsMid,Chart,DtrStore,DtrStoreRest):-
>   !,d_add_to(LDtr,FS,edge),
>   d_add_to(LMother,FS2,mother),
>   PrevDtrsMid = [N], DtrStoreRest = [FS],
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   d_add_edge(Left,Right,FS2,PrevDtrs,RuleName,Chart).
> d_add_dtrs(lcats(LDtrs),FS,Left,Right,N,LMother,RuleName,PrevDtrs,
>            PrevDtrsMid,Chart,DtrStore,DtrStoreRest) :-
>   !,d_add_to(LDtrs,FS3,dtrlist),
>   get_type(FS3,Sort),
>   ( ale_lists_defined -> clause(fcolour(hd,HdPos,_),true),
>                          clause(fcolour(tl,TlPos,_),true)
>   ; strip_labels(LDtrs,Dtrs),
>     raise_exception(cats_no_lists(RuleName,Dtrs))
>   ),
>   ((Sort == e_list) ->
>      fail
>   ; (d_match_list(Sort,FS3,HdPos,TlPos,FS,Right,N,PrevDtrsMid,[],NextRight,Chart,DtrStoreRest,[]),
>      d_add_to(LMother,FS2,mother),
>      d_apply_forall_rule(DtrStore,FS2,RuleName),
>      d_add_edge(Left,NextRight,FS2,PrevDtrs,RuleName,Chart))).
> d_add_dtrs(remainder(TlFS),FS,Left,Right,N,LMother,RuleName,PrevDtrs,PrevDtrsMid,
> 	   Chart,DtrStore,DtrStoreRest) :-
>   !, get_type(TlFS,Sort),
>   clause(fcolour(hd,HdPos,_),true),
>   clause(fcolour(tl,TlPos,_),true),  
>   d_match_list(Sort,TlFS,HdPos,TlPos,FS,Right,N,PrevDtrsMid,[],NextRight,Chart,DtrStoreRest,[]),
>   d_add_to(LMother,FS2,mother),
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   d_add_edge(Left,NextRight,FS2,PrevDtrs,RuleName,Chart).
> 
> d_add_dtrs_rest((lcat(LDtr),Rest),Left,Right,LMother,
>                 PrevDtrs,[N|DtrsRest],RuleName,Chart,DtrStore,DtrStoreMid):-
>   !,get_edge(Right,Chart,N,NewRight,FS,_,ERN),
>   d_edge_announce_retrieve(N,Right,NewRight,ERN),
>   d_add_to(LDtr,FS,edge), DtrStoreMid = [FS|DtrStoreRest],
>   d_add_dtrs_rest(Rest,Left,NewRight,LMother,PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreRest).
> d_add_dtrs_rest((lsem_head(LDtr),Rest),Left,Right,LMother,
>                 PrevDtrs,[N|DtrsRest],RuleName,Chart,DtrStore,DtrStoreMid):-
>   !,get_edge(Right,Chart,N,NewRight,FS,_,ERN),
>   d_edge_announce_retrieve(N,Right,NewRight,ERN),
>   d_add_to(LDtr,FS,edge), DtrStoreMid = [FS|DtrStoreRest],
>   d_add_dtrs_rest(Rest,Left,NewRight,LMother,PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreRest).
> d_add_dtrs_rest((lcats(LDtrs),Rest),Left,Right,LMother,
>                 PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreMid) :-
>   !,d_add_to(LDtrs,FS,dtrlist),
>   get_type(FS,Sort),
>   ( ale_lists_defined -> clause(fcolour(hd,HdPos,_),true),
>                          clause(fcolour(tl,TlPos,_),true)
>   ; strip_labels(LDtrs,Dtrs),
>     raise_exception(cats_no_lists(RuleName,Dtrs))
>   ),
>   d_match_list_rest(Sort,FS,HdPos,TlPos,Right,NewRight,DtrsRest,DtrsRest2,Chart,DtrStoreMid,DtrStoreRest),
>   d_add_dtrs_rest(Rest,Left,NewRight,LMother,PrevDtrs,DtrsRest2,RuleName,Chart,DtrStore,DtrStoreRest).
> d_add_dtrs_rest((lgoal(LGoal),Rest),Left,Right,LMother,
>                 PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreMid):-
>   !, d_query(LGoal),
>   d_add_dtrs_rest(Rest,Left,Right,LMother,PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreMid).
> d_add_dtrs_rest((lsem_goal(LGoal),Rest),Left,Right,LMother,
>                 PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreMid):-
>   !, d_query(LGoal),
>   d_add_dtrs_rest(Rest,Left,Right,LMother,PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreMid).
> d_add_dtrs_rest(lcat(LDtr),Left,Right,LMother,PrevDtrs,[N],RuleName,Chart,DtrStore,DtrStoreRest):-
>   !,get_edge(Right,Chart,N,NewRight,FS,_,ERN),
>   d_edge_announce_retrieve(N,Right,NewRight,ERN),
>   d_add_to(LDtr,FS,edge),
>   d_add_to(LMother,FS2,mother),
>   DtrStoreRest = [FS],
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   d_add_edge(Left,NewRight,FS2,PrevDtrs,RuleName,Chart).
> d_add_dtrs_rest(lsem_head(LDtr),Left,Right,LMother,PrevDtrs,[N],RuleName,Chart,DtrStore,DtrStoreRest):-
>   !,get_edge(Right,Chart,N,NewRight,FS,_,ERN),
>   d_edge_announce_retrieve(N,Right,NewRight,ERN),
>   d_add_to(LDtr,FS,edge),
>   d_add_to(LMother,FS2,mother),
>   DtrStoreRest = [FS],
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   d_add_edge(Left,NewRight,FS2,PrevDtrs,RuleName,Chart).
> d_add_dtrs_rest(lcats(LDtrs),Left,Right,LMother,PrevDtrs,DtrsRest,RuleName,Chart,DtrStore,DtrStoreRest) :-
>   !,d_add_to(LDtrs,FS,dtrlist),
>   get_type(FS,Sort),
>   ( ale_lists_defined -> clause(fcolour(hd,HdPos,_),true),
>                          clause(fcolour(tl,TlPos,_),true)
>   ; strip_labels(LDtrs,Dtrs),
>     raise_exception(cats_no_lists(RuleName,Dtrs))
>   ),
>   d_match_list_rest(Sort,FS,HdPos,TlPos,Right,NewRight,DtrsRest,[],Chart,DtrStoreRest,[]),
>   d_add_to(LMother,FS2,mother),
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   d_add_edge(Left,NewRight,FS2,PrevDtrs,RuleName,Chart).
> d_add_dtrs_rest(lgoal(LGoal),Left,Right,LMother,PrevDtrs,[],RuleName,Chart,DtrStore,[]):-
>   !, d_query(LGoal),
>   d_add_to(LMother,FS2,mother),
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   d_add_edge(Left,Right,FS2,PrevDtrs,RuleName,Chart).
> d_add_dtrs_rest(lsem_goal(LGoal),Left,Right,LMother,PrevDtrs,[],RuleName,Chart,DtrStore,[]):-
>   !, d_query(LGoal),
>   d_add_to(LMother,FS2,mother),
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   d_add_edge(Left,Right,FS2,PrevDtrs,RuleName,Chart).
> 
> d_match_list(Sort,ListFS,HdPos,TlPos,FS,Right,N,[N|DtrsMid],DtrsRest,NextRight,Chart,DtrStore,DtrStoreRest) :-
>   sub_type(ne_list,Sort),
>   !, arg(HdPos,ListFS,FS),
>   arg(TlPos,ListFS,TlFS),
>   get_type(TlFS,TlSort),
>   DtrStore = [FS|DtrStoreMid],
>   d_match_list_rest(TlSort,TlFS,HdPos,TlPos,Right,NextRight,DtrsMid,DtrsRest,Chart,DtrStoreMid,DtrStoreRest).
> d_match_list(Sort,_,_,_,_,_,_,_,_,_,_,_,_) :-
>   error_msg((nl,write('error: cats> value with sort, '),write(Sort),
>             write(' is not a valid list argument'))).
> 
> d_match_list_rest(e_list,_,_,_,Right,Right,DtrsRest,DtrsRest,_,DtrStore,DtrStore) :- 
>   !.
> d_match_list_rest(Sort,ListFS,HdPos,TlPos,Right,NewRight,[N|DtrsRest],DtrsRest2,Chart,DtrStore,DtrStoreRest) :-
>   sub_type(ne_list,Sort),
>   !, arg(HdPos,ListFS,HdFS),
>   get_edge(Right,Chart,N,MidRight,HdFS,_,ERN),
>   d_edge_announce_retrieve(N,Right,MidRight,ERN),
>   arg(TlPos,ListFS,TlFS),
>   get_type(TlFS,TlSort),
>   DtrStore = [HdFS|DtrStoreMid],
>   d_match_list_rest(TlSort,TlFS,HdPos,TlPos,MidRight,NewRight,DtrsRest,DtrsRest2,Chart,DtrStoreMid,DtrStoreRest).
> d_match_list_rest(Sort,_,_,_,_,_,_,_,_,_,_) :-
>   error_msg((nl,write('error: cats> value with sort, '),write(Sort),
>             write(' is not a valid list argument'))).
> 
> d_apply_forall_rule(DtrStore,MotherFS,RuleName) :-
>   ( current_predicate(lforall_rule,lforall_rule(_,_,_))
>   ->  d_meta_interp(forall_rules(RuleName,MotherFS),[],d_apply_forall_rules(DtrStore,MotherFS,RuleName))
>   ; true
>   ).
> 
> d_apply_forall_rules(_,_,_) :-
>   findall(Name,lforall_rule(Name,_,_),Names),
>   has_duplicates(Names),
>   append(_,[Name|Rest],Names), member_eq(Name,Rest),
>   raise_exception(ale(forall_rule_dup(Name))).	
> d_apply_forall_rules(DtrStore,MotherFS,RuleName) :-
>   findall(lforall_rule(Name,ForallLine,LDoRule),lforall_rule(Name,ForallLine,LDoRule),LFARules),
>   ( ale_lists_defined -> add_to(DtrStore,Dtrs) ; Dtrs = (a_ DtrStore) ),
>   d_apply_forall_rules_act(LFARules,Dtrs,MotherFS,RuleName).
> 
> d_apply_forall_rules_act([],_,_,_).
> d_apply_forall_rules_act([lforall_rule(Name,ForallLine,LDoRule)|LFARules],Dtrs,MotherFS,RuleName) :-
>   d_meta_interp(forall_rule(Name,MotherFS,RuleName),ForallLine,
>                 d_apply_forall_rule0(Dtrs,MotherFS,RuleName,LDoRule)),
>   d_apply_forall_rules_act(LFARules,Dtrs,MotherFS,RuleName).
> 
> d_apply_forall_rule0(Dtrs,MotherFS,RuleName,
>                      ldo_rule(RuleName0,RuleLabel,MotherCond,ArrowLabel,RuleRHSCond,LabelledDoBody)) :-
>   d_meta_interp(match_forall_rule_name(RuleName0,MotherFS,RuleName),RuleLabel,(RuleName = RuleName0)),
>   d_meta_interp(match_forall_rule(Dtrs,MotherFS,RuleName),ArrowLabel,
> 		d_query(lwhen(ArrowLabel,(MotherFS=MotherCond,Dtrs=RuleRHSCond),LabelledDoBody))).
> 
> nv_replace_lbody((GD1,GD2),(NG1,NG2),Args,ArgsRest,NVs) :-
>   !,nv_replace_lbody(GD1,NG1,Args,ArgsMid,NVs),
>     nv_replace_lbody(GD2,NG2,ArgsMid,ArgsRest,NVs).
> nv_replace_lbody((GD1;GD2),(NG1;NG2),Args,ArgsRest,NVs) :-
>   !,nv_replace_lbody(GD1,NG1,Args,ArgsMid,NVs),
>     nv_replace_lbody(GD2,NG2,ArgsMid,ArgsRest,NVs).
> nv_replace_lbody(lshallow(_,LG1,LG2,LG3),(NG1 -> NG2 ; NG3),Args,ArgsRest,NVs) :-
>   !,nv_replace_lbody(LG1,NG1,Args,ArgsMid,NVs),
>   nv_replace_lbody(LG2,NG2,ArgsMid,ArgsMid2,NVs),
>   nv_replace_lbody(LG3,NG3,ArgsMid2,ArgsRest,NVs).
> nv_replace_lbody(lneg(_,G1),(\+ NG1),Args,ArgsRest,NVs) :-
>   !,nv_replace_lbody(G1,NG1,Args,ArgsRest,NVs).
> nv_replace_lbody(lprolog(_,Hook),prolog(Hook),Args,Args,_NVs) :-
>   !.
> nv_replace_lbody(lprolog(_,NVs,Hook),prolog(NVs,Hook),Args,Args,NVs) :-
>   !.
> nv_replace_lbody(lwhen(_,Cond,Body),when(NCond,NBody),Args,ArgsRest,NVs) :-
>   !, nv_replace_lcond(Cond,NCond,Args,ArgsMid,NVs,NewNVs),
>   nv_replace_lbody(Body,NBody,ArgsMid,ArgsRest,NewNVs).
> nv_replace_lbody(ltrue,true,Args,Args,_).
> nv_replace_lbody(lfail,fail,Args,Args,_).
> nv_replace_lbody(lcut,!,Args,Args,_).
> nv_replace_lbody(lexteq(_,LD1,LD2),(ND1 =@ ND2),Args,ArgsRest,NVs) :-
>   nv_replace_ldescs([LD1,LD2],[ND1,ND2],Args,ArgsRest,NVs).
> nv_replace_lbody(lunify(_,LD1,LD2),(ND1 = ND2),Args,ArgsRest,NVs) :-
>   nv_replace_ldescs([LD1,LD2],[ND1,ND2],Args,ArgsRest,NVs).
> nv_replace_lbody(lcomp(Functor,_,_,LDList),Goal,Args,ArgsRest,NVs) :-
>   nv_replace_ldescs(LDList,NDList,Args,ArgsRest,NVs),
>   Goal =.. [Functor|NDList].
> 
> nv_replace_ldescs([],[],Args,Args,_).
> nv_replace_ldescs([LD|LDs],[ND|NDs],Args,ArgsRest,NVs) :-
>   nv_replace_ldesc(LD,ND,Args,ArgsMid,NVs),
>   nv_replace_ldescs(LDs,NDs,ArgsMid,ArgsRest,NVs).
> 
> nv_replace_ldesc(lvar(X,_,_),NX,Args,ArgsRest,NVs) :-
>   !, ( get_assoc(X,NVs,seen(NX)) -> true
>      ; NX = X),
>      ( var(NX) -> ArgsRest = Args
>      ; Args = [NX|ArgsRest]).
> nv_replace_ldesc(lelist(_),[],Args,Args,_) :- !.
> nv_replace_ldesc(lnelist(_,_,LH,LT),[NH|NT],Args,ArgsRest,NVs) :-
>   !,nv_replace_ldesc(LH,NH,Args,ArgsMid,NVs),
>   nv_replace_ldesc(LT,NT,ArgsMid,ArgsRest,NVs).
> nv_replace_ldesc(lpatheq(P1,P2,_,_,_),P1==P2,Args,Args,_) :- !.
> nv_replace_ldesc(lineq(_,LD),=\= NDesc,Args,ArgsRest,NVs) :-
>   !,nv_replace_ldesc(LD,NDesc,Args,ArgsRest,NVs).
> nv_replace_ldesc((lfeat(Feat,_):LDesc),Feat:NDesc,Args,ArgsRest,NVs) :-
>   !,nv_replace_ldesc(LDesc,NDesc,Args,ArgsRest,NVs).
> nv_replace_ldesc((D1,D2),(ND1,ND2),Args,ArgsRest,NVs) :-
>   !,nv_replace_ldesc(D1,ND1,Args,ArgsMid,NVs),
>   nv_replace_ldesc(D2,ND2,ArgsMid,ArgsRest,NVs).
> nv_replace_ldesc((D1;D2),(ND1;ND2),Args,ArgsRest,NVs) :-
>   !,nv_replace_ldesc(D1,ND1,Args,ArgsMid,NVs),
>   nv_replace_ldesc(D2,ND2,ArgsMid,ArgsRest,NVs).
> nv_replace_ldesc(lmac(LMacro,_),(@ NMacro),Args,ArgsRest,NVs) :-
>   !, LMacro =.. [Name|LDescs],
>   nv_replace_ldescs(LDescs,NDescs,Args,ArgsRest,NVs),
>   NMacro =.. [Name|NDescs].
> nv_replace_ldesc(latom(X,_),a_ X,Args,Args,_) :- !.
> nv_replace_ldesc(lfun(lcomp(Functor,_,_,LDList)),NF,Args,ArgsRest,NVs) :-
>   nv_replace_ldescs(LDList,NDList,Args,ArgsRest,NVs),
>   NF =.. [Functor|NDList].
> nv_replace_ldesc(ltype(Type,_),Type,Args,Args,_).
> 
> nv_lreplace_ldesc(lvar(X,XName,XLine),lvar(NX,XName,XLine),Args,ArgsRest,NVs) :-
>   !, ( get_assoc(X,NVs,seen(NX)) -> true
>      ; NX = X),
>      ( var(NX) -> ArgsRest = Args
>      ; Args = [NX|ArgsRest]).
> nv_lreplace_ldesc(lelist(Line),lelist(Line),Args,Args,_) :- !.
> nv_lreplace_ldesc(lnelist(LBrackLine,TailLine,LH,LT),lnelist(LBrackLine,TailLine,NH,NT),
> 		  Args,ArgsRest,NVs) :-
>   !,nv_lreplace_ldesc(LH,NH,Args,ArgsMid,NVs),
>   nv_lreplace_ldesc(LT,NT,ArgsMid,ArgsRest,NVs).
> nv_lreplace_ldesc(lpatheq(P1,P2,OpLine,LP1,LP2),lpatheq(P1,P2,OpLine,LP1,LP2),Args,Args,_) :- !.
> nv_lreplace_ldesc(lineq(OpLine,LD),lineq(OpLine,NDesc),Args,ArgsRest,NVs) :-
>   !,nv_lreplace_ldesc(LD,NDesc,Args,ArgsRest,NVs).
> nv_lreplace_ldesc((lfeat(Feat,FLine):LDesc),lfeat(Feat,FLine):NDesc,Args,ArgsRest,NVs) :-
>   !,nv_lreplace_ldesc(LDesc,NDesc,Args,ArgsRest,NVs).
> nv_lreplace_ldesc((D1,D2),(ND1,ND2),Args,ArgsRest,NVs) :-
>   !,nv_lreplace_ldesc(D1,ND1,Args,ArgsMid,NVs),
>   nv_lreplace_ldesc(D2,ND2,ArgsMid,ArgsRest,NVs).
> nv_lreplace_ldesc((D1;D2),(ND1;ND2),Args,ArgsRest,NVs) :-
>   !,nv_lreplace_ldesc(D1,ND1,Args,ArgsMid,NVs),
>   nv_lreplace_ldesc(D2,ND2,ArgsMid,ArgsRest,NVs).
> nv_lreplace_ldesc(lmac(LMacro,OpLine),lmac(NMacro,OpLine),Args,ArgsRest,NVs) :-
>   !, LMacro =.. [Name|LDescs],
>   nv_lreplace_ldescs(LDescs,NDescs,Args,ArgsRest,NVs),
>   NMacro =.. [Name|NDescs].
> nv_lreplace_ldesc(latom(X,ALine),latom(X,ALine),Args,Args,_) :- !.
> nv_lreplace_ldesc(lfun(lcomp(Functor,Arity,FunLine,LDList)),
> 		  lfun(lcomp(Functor,Arity,FunLine,NDList)),Args,ArgsRest,NVs) :-
>   nv_lreplace_ldescs(LDList,NDList,Args,ArgsRest,NVs).
> nv_lreplace_ldesc(ltype(Type,TLine),ltype(Type,TLine),Args,Args,_).
> 
> nv_lreplace_ldescs([],[],Args,Args,_).
> nv_lreplace_ldescs([LD|LDescs],[ND|NDescs],Args,ArgsRest,NVs) :-
>   nv_lreplace_ldesc(LD,ND,Args,ArgsMid,NVs),
>   nv_lreplace_ldescs(LDescs,NDescs,ArgsMid,ArgsRest,NVs).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % dgen/1,3: Interactive generator
> dgen(Desc) :-
>   reset_d_mode,
>   reset_d_skip_level,
>   label_query_arg(Desc,LDesc),
>   call_residue((d_add_to(LDesc,FS,query_desc),
> 		frozen_term(FS,Frozen),
> 		((current_predicate(portray_cat,portray_cat(_,_,_,_)),
> 		  portray_cat(_,Desc,FS,Frozen)) -> true
> 		; nl, write('INITIAL CATEGORY: '), nl, ttyflush,
> 		  pp_fs_res(FS,Frozen), nl
> 		),
>                 d_gen(FS,Words)),Residue),
>   ((current_predicate(portray_cat,portray_cat(_,_,_,_)),
>     portray_cat(Words,Desc,FS,Residue)) -> true
>   ; nl, write('STRING: '),
>     nl, write_list(Words),
>     \+ \+ (nl, write('FINAL CATEGORY: '),nl, ttyflush,
> 	   pp_fs_res(FS,Residue)), nl
>   ),
>   query_proceed.
>  
> dgen(FS) :-
>   reset_d_mode,
>   reset_d_skip_level,
>   call_residue((frozen_term(FS,Frozen),
> 		((current_predicate(portray_cat,portray_cat(_,_,_,_)),
> 		  portray_cat(_,bot,FS,Frozen)) -> true
> 		; nl, write('INITIAL CATEGORY: '), nl, ttyflush,
> 		  pp_fs_res(FS,Frozen), nl
> 		),
>                 d_gen(FS,Words)),Residue),		
>   ((current_predicate(portray_cat,portray_cat(_,_,_,_)),
>     portray_cat(Words,bot,FS,Residue)) -> true
>   ; nl, write('STRING: '),
>     nl, write_list(Words),
>     \+ \+ (nl, write('FINAL CATEGORY: '),nl, ttyflush,
> 	   pp_fs_res(FS,Residue)), nl
>   ),
>   query_proceed.
> 
>   
> %d_gen(Tag,SVs) :-
> %  nl, write('QUERY: '), nl, ttyflush,
> %  pp_fs(Tag-SVs), nl,
> %  d_gen(Tag,SVs,Words),
> %  nl, write('STRING: '),
> %  nl, write_list(Words),
> %  nl, query_proceed.
> 
> dgen(FS,Words) :-
>   reset_d_mode,
>   reset_d_skip_level,
>   d_gen(FS,Words).
> 
> d_gen(FS,Words) :-
>   ( [no,semantics,specification,found] if_warning_else_fail
>       (\+ current_predicate(semantics,semantics(_))),
>       !
>   ; semantics(Pred), Goal =.. [Pred,_,_],
>     [no,Pred,definite,clause,found] if_warning_else_fail
>       (\+ current_predicate(if,if(Goal,_))), !
>   ; d_generate(FS,Words,[],0,query)
>   ).   
> 
> d_generate(FS,Words,RestWords,RootSource) :-
>   current_predicate(lsemantics,lsemantics(_,_)),
>   lsemantics(DirLine,Pred),
>   d_meta_interp(sem_index(FS,IndexFS,RootSource),DirLine,
> 		d_solve_goal(Pred,2,[FS,IndexFS])),
>   d_call_fail(pivot_tmpl(IndexFS,PivotFS,RootSource),DirLine,
> 	      d_solve_goal(Pred,2,[PivotFS,IndexFS])),
>   d_meta_interp(pivot_find(PivotFS,PivotSource,RootSource),[],
> 		d_non_chain_rule(PivotFS,LDtrs,PivotSource,NCLine,RootSource)),
>   (\+ \+  % do not commit to test chain - NOTE: compiled generator does
>   (current_chain_length(Max),
>    d_meta_interp(chain_check(FS,PivotFS,PivotSource,RootSource,pivot),[],
>                  d_chained_nodes(0,Max,PivotFS,FS,
> 				 PivotSource,RootSource,pivot))
>   )),
>   d_meta_interp(pivot_gen(NewWords,RestNewWords,PivotSource,RootSource,PivotGenPortFlag),NCLine,
> 		(PivotGenPortFlag=1,d_gen_dtrs(LDtrs,NewWords,RestNewWords,1,_,PivotSource))),
>   current_chain_length(Max),
>   d_meta_interp(pivot_conn(FS,PivotFS,Words,RestWords,NewWords,RestNewWords,
>                            PivotSource,RootSource,PivotConnPortFlag),[],
>                 (PivotConnPortFlag=1,
> 		 d_conn(0,Max,PivotFS,FS,NewWords,RestNewWords,
> 		        Words,RestWords,PivotSource,RootSource,pivot)
> 		)).
> 
> :- discontiguous d_non_chain_rule/5.
> d_non_chain_rule(PivotFS,(word> Word),PivotSource,WordLine,RootSource) :-
>   current_predicate('l--->','l--->'(_,_,_,_)),
>   'l--->'(WordStart,WordLine,LabelledDescStart,LabelledGoalStart),
>   d_meta_interp(pivot_lex(WordStart,PivotFS,RootSource),WordLine,
> 		d_non_chain_rule_act(LabelledDescStart,WordStart,LabelledGoalStart,
> 				     Word,PivotFS,PivotSource,RootSource)).
>   d_non_chain_rule_act(LabelledDescStart,WordStart,LabelledGoalStart,Word,PivotFS,
>   		       PivotSource,RootSource) :-
>     d_add_to(LabelledDescStart,FS,lex),
>     curr_lex_rule_depth(Max),
>     d_gen_lex_close(0,Max,WordStart,FS,LabelledGoalStart,Word,PivotFS,
> 		    PivotSource,RootSource).
> 
> % KNOWN BUG: compiled generator cuts off chain-rule phonologies when pivot is
> %  an empty cat
> d_non_chain_rule(PivotFS,empty,empty,OpLine,RootSource) :-
>   current_predicate(lemptyentry,lemptyentry(_,_)),
>   lemptyentry(OpLine,LDesc),
>   d_meta_interp(pivot_empty(PivotFS,RootSource),OpLine,d_add_to(LDesc,PivotFS,pivot)).
> d_non_chain_rule(PivotFS,LabelledRuleBody,ncrule(RuleName),RuleLine,RootSource) :-
>   current_predicate(lrule,lrule(_,_,_,_)),
>   lrule(RuleName,RuleLine,LabelledMother,LabelledRuleBody),
>   \+ d_chain_rule_body(LabelledRuleBody),
>   d_meta_interp(pivot_ncrule(RuleName,PivotFS,RootSource),RuleLine,
>                 d_add_to(LabelledMother,PivotFS,pivot)).
> 
> d_gen_lex_close(N,_,Word,FS,LabelledGoal,Word,PivotFS,PivotSource,RootSource) :-
>   d_meta_interp(lex_pivot_unify(Word,FS,PivotFS,RootSource),[],
>                 (FS=PivotFS)),
>   (N =:= 0
>   -> PivotSource = base(Word)
>    ; PivotSource = deriv(Word,_)),
>   d_query(LabelledGoal).
> d_gen_lex_close(N,Max,WordIn,FS,LGoal,WordOut,PivotFS,PivotSource,RootSource) :-
>   current_predicate(llr,llr(_,_,_)),
>   N < Max,
>   d_lex_rule(WordIn,FS,LGoal,WordMid,FSMid,LGoalMid),
>   NewN is N + 1,
>   (N =:= 0
>   -> PivotSource = deriv(_,WordIn)
>    ; true),
>   d_gen_lex_close(NewN,Max,WordMid,FSMid,LGoalMid,WordOut,PivotFS,PivotSource,RootSource).
> 
> % NOTE:
> % This is different from the way the compiled system links chains.  For
> %  some reason, that one links top-down,
> %  in spite of the fact that van Noord's algorithm applies chain rules
> %  bottom-up.  The compiled system also switches over to the interpreted
> %  system after one pass.
> d_chained_nodes(_,_,ChainFS,RootFS,PivotSource,RootSource,ChainSource) :-
>   d_meta_interp(root_chain_unify(RootFS,ChainFS,PivotSource,RootSource,ChainSource),
>                 [],(ChainFS=RootFS)).
> d_chained_nodes(N,Max,ChainFS,RootFS,PivotSource,RootSource,ChainSource) :-
>   current_predicate(lrule,lrule(_,_,_,_)),
>   N < Max,
>   lrule(RuleName,RuleLine,LabelledMother,LabelledRuleBody),
>   d_chain_rule_body(LabelledRuleBody,_,LSemHead,_),
>   d_meta_interp(chain_crule(RuleName,RootFS,ChainFS,PivotSource,RootSource,ChainSource),
>                 RuleLine,
> 		d_chained_nodes_lrule(ChainFS,NewChainFS,LSemHead,LabelledMother)),
>   NewN is N + 1,
>   d_meta_interp(chain_check(RootFS,NewChainFS,PivotSource,RootSource,crule(RuleName)),
>                 [],d_chained_nodes(NewN,Max,NewChainFS,RootFS,
>                                    PivotSource,RootSource,crule(RuleName))).
>   d_chained_nodes_lrule(ChainFS,NewChainFS,LSemHead,LabelledMother) :-
>     d_add_to(LSemHead,ChainFS,pivot),
>     d_add_to(LabelledMother,NewChainFS,mother).
> 
> 
> d_gen_dtrs(empty,Words,Words,N,N,_) :- !.
> d_gen_dtrs((word> Word),[Word|RestWords],RestWords,N,SN,_) :-
>   !,SN is N + 1.
> d_gen_dtrs(lcat(LDtr),Words,RestWords,N,SN,RuleSource) :-
>   !,d_add_to(LDtr,DtrFS,nonheaddtr(N,RuleSource)),
>   d_generate(DtrFS,Words,RestWords,nonheaddtr(N,RuleSource)),
>   SN is N + 1.
> d_gen_dtrs((lcat(LDtr),RestDtrs),Words,RestWords,N,NewN,RuleSource) :-
>   !,d_add_to(LDtr,DtrFS,nonheaddtr(N,RuleSource)),
>   d_generate(DtrFS,Words,MidWords,nonheaddtr(N,RuleSource)),
>   SN is N + 1,
>   d_gen_dtrs(RestDtrs,MidWords,RestWords,SN,NewN,RuleSource).
> d_gen_dtrs(lgoal(LGoal),Words,Words,N,N,_) :-
>   !,d_query(LGoal).
> % NOTE: gen_dtrs had a clause for sem_goal, which shouldn't be in non-chain
> %  rules - gen_dtrs was also used to process sem_goals from chain rules
> d_gen_dtrs((lgoal(LGoal),RestDtrs),Words,RestWords,N,NewN,RuleSource) :-
>   !,d_query(LGoal),
>   d_gen_dtrs(RestDtrs,Words,RestWords,N,NewN,RuleSource).
> d_gen_dtrs(lcats(LDtrsList),Words,RestWords,N,NewN,RuleSource) :-
>   !,d_add_to(LDtrsList,FS,dtrlist),
>   get_type(FS,Sort),
>   ( ale_lists_defined -> clause(fcolour(hd,HdPos,_),true),
>                          clause(fcolour(tl,TlPos,_),true)
>   ; strip_labels(LDtrsList,Dtrs),
>     functor(RuleSource,_,N),
>     ( N > 0 -> arg(1,RuleSource,RuleName) ; RuleName = RuleSource),
>     raise_exception(cats_no_lists(RuleName,Dtrs))
>   ),
>   d_gen_list_dtrs(Sort,FS,HdPos,TlPos,Words,RestWords,N,NewN,RuleSource).
> d_gen_dtrs((lcats(LDtrsList),RestDtrs),Words,RestWords,N,NewN,RuleSource) :-
>   !,d_add_to(LDtrsList,FS,dtrlist),
>   get_type(FS,Sort),
>   ( ale_lists_defined -> clause(fcolour(hd,HdPos,_),true),
>                          clause(fcolour(tl,TlPos,_),true)
>   ; strip_labels(LDtrsList,Dtrs),
>     functor(RuleSource,_,N),
>     ( N > 0 -> arg(1,RuleSource,RuleName) ; RuleName = RuleSource),      
>     raise_exception(cats_no_lists(RuleName,Dtrs))
>   ),
>   d_gen_list_dtrs(Sort,FS,HdPos,TlPos,Words,MidWords,N,NextN,RuleSource),
>   d_gen_dtrs(RestDtrs,MidWords,RestWords,NextN,NewN,RuleSource).
> 
> d_gen_list_dtrs(e_list,_,_,_,Words,Words,N,N,_) :-
>   !.
> d_gen_list_dtrs(Sort,ListFS,HdPos,TlPos,Words,RestWords,N,NewN,RuleSource) :-
>   sub_type(ne_list,Sort),
>   !, arg(HdPos,ListFS,HdFS),
>   d_generate(HdFS,Words,MidWords,nonheaddtr(N,RuleSource)),
>   arg(TlPos,ListFS,TlFS),
>   get_type(TlFS,TlSort),
>   SN is N + 1,
>   d_gen_list_dtrs(TlSort,TlFS,HdPos,TlPos,MidWords,RestWords,SN,NewN,RuleSource).
> 
> % NOTE: conn doesn't keep track of max. chain length (although chained_nodes
> %  does)
> d_conn(_,_,PivotFS,RootFS,Words,RestWords,
>        Words,RestWords,PivotSource,RootSource,ChainSource) :-
>   d_meta_interp(root_chain_unify(RootFS,PivotFS,PivotSource,RootSource,ChainSource),
>                 [],(PivotFS=RootFS)).
> d_conn(N,Max,PivotFS,RootFS,HeadWords,RestHeadWords,Words,RestWords,
>        PivotSource,RootSource,ChainSource) :-
>   current_predicate(lrule,lrule(_,_,_,_)),
>   N < Max,
>   lrule(RuleName,RuleLine,LabelledMother,LabelledRuleBody),
>   d_chain_rule_body(LabelledRuleBody,LSemGoalBefore,LSemHead,LSemGoalAfter,
>                     PrevDtrs,NextDtrs),
>   d_meta_interp(chain_crule(RuleName,RootFS,PivotFS,PivotSource,RootSource,ChainSource),
>                 RuleLine,d_conn_lrule(LSemGoalBefore,PivotFS,LSemHead,LSemGoalAfter,
> 				      LabelledMother,ChainFS)),
>   NewN is N + 1,
>   (\+ \+  % don't commit to test chain - NOTE: compiled generator does
>    d_meta_interp(chain_check(RootFS,ChainFS,PivotSource,RootSource,crule(RuleName)),
>                  [],
>                  d_chained_nodes(NewN,Max,ChainFS,RootFS,PivotSource,RootSource,
>                                  crule(RuleName)))
>   ),
>   d_meta_interp(pre_chain_gen(NewWords,HeadWords,RestHeadWords,PivotSource,RootSource,ChainSource,
> 			      PreChainGenPortFlag),
>                 RuleLine,
> 		(PreChainGenPortFlag=1,d_gen_dtrs(PrevDtrs,NewWords,HeadWords,1,DtrNum,
> 						  crule(RuleName)))),
>   d_meta_interp(post_chain_gen(NewWords,HeadWords,RestHeadWords,RestNewWords,PivotSource,RootSource,
>                                ChainSource,PostChainGenPortFlag),
>                 RuleLine,
> 		(PostChainGenPortFlag=1,d_gen_dtrs(NextDtrs,RestHeadWords,RestNewWords,DtrNum,_,
> 						   crule(RuleName)))),
>   d_meta_interp(new_chain_conn(RootFS,ChainFS,Words,NewWords,RestNewWords,RestWords,
> 		  	       PivotSource,RootSource,crule(RuleName),NewChainConnPortFlag),
>                 [],
> 		(NewChainConnPortFlag=1,d_conn(NewN,Max,ChainFS,RootFS,NewWords,
> 					       RestNewWords,Words,RestWords,PivotSource,RootSource,
> 					       crule(RuleName)))).
>   d_conn_lrule(LSemGoalBefore,PivotFS,LSemHead,LSemGoalAfter,LabelledMother,ChainFS) :-
>     (LSemGoalBefore = empty -> true
>     ; d_query(LSemGoalBefore)
>     ),
>     d_add_to(LSemHead,PivotFS,sem_head),
>     (LSemGoalAfter = empty -> true
>      ; d_query(LSemGoalAfter)
>     ),
>     d_add_to(LabelledMother,ChainFS,mother).
> 
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Debugger options
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % dclear_bps/0: clear all breakpoints
> dclear_bps :-
>   retractall(ale_break(_)).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % dspy/1: set spypoint
> 
> dspy(Spec) :-
>   ( Spec = (Functor/Arity)
>   -> \+ if((current_predicate(lif,lif(_,_)),lif(lcomp(Functor,Arity,Line,_),_)),
>            (set_ale_break(Line),fail),
> 	   (format(user_error,'{~p: no matching predicate}~n',[Spec]),fail)
>           )
> %     set_d_mode(leap),
> %     format(user_error,'{The debugger will first leap}~n',[])
>   ; format(user_error, '{~p is not of the form Functor/Arity}~n', [Spec])
>   ).
> 
> dspy_rule(Name) :-
>   \+ if((current_predicate(lrule,lrule(_,_,_,_)),lrule(Name,Line,_,_)),
>         (set_ale_break(Line),fail),
>         (format(user_error,'{~p: no matching rule}~n',[Name]),fail)
>        ).
> %  format(user_error,'{The debugger will first leap}~n',[]).
> 
> dspy_lr(Name) :-
>   \+ if((current_predicate(llr,llr(_,_,_)),llr(Name,Line,_)),
> 	(set_ale_break(Line),fail),
>         (format(user_error,'{~p: no matching lexical rule}~n',[Name]),fail)
>        ).
> %  format(user_error,'{The debugger will first leap}~n',[]).
> 
> dspy_lex(Word) :-
>   \+ if((current_predicate('l--->','l--->'(_,_,_,_)),'l--->'(Word,Line,_,_)),
> 	(set_ale_break(Line),fail),
>         (format(user_error,'{~p: no matching lexical entry}~n',[Word]),fail)
>        ).
> %  format(user_error,'{The debugger will first leap}~n',[]).
> 
> dspy_fun(Spec) :-
>   ( Spec = (Functor/Arity)
>   -> \+ if((current_predicate('l+++>','l+++>'(_,_)),'l+++>'(lcomp(Functor,Arity,Line,_),_)),
>            (set_ale_break(Line),fail),
> 	   (format(user_error,'{~p: no matching function declaration}~n',[Spec]),fail)
>           )
> %     set_d_mode(leap),
> %     format(user_error,'{The debugger will first leap}~n',[])
>   ; format(user_error, '{~p is not of the form Functor/Arity}~n', [Spec])
>   ).
> 
> dspy_macro(Spec) :-
>   ( Spec = (Functor/Arity)
>   -> \+ if((current_predicate(lmacro,lmacro(_,_,_)),lmacro(Head,Line,_),functor(Head,Functor,Arity)),
>            (set_ale_break(Line),fail),
> 	   (format(user_error,'{~p: no matching macro declaration}~n',[Spec]),fail)
>           )
> %     set_d_mode(leap),
> %     format(user_error,'{The debugger will first leap}~n',[])
>   ; format(user_error, '{~p is not of the form Functor/Arity}~n', [Spec])
>   ).
>   
> dspy_cons(Type) :-
>   ( type(Type)
>   -> \+ if((current_predicate(lcons,lcons(_,_,_,_,_)),lcons(Type,Line,_,_,_)),
>            (set_ale_break(Line),fail),
> 	   (format(user_error,'{no constraint for type ~p}~n',[Type]),fail)
>           )
> %     set_d_mode(leap),
> %     format(user_error,'{The debugger will first leap}~n',[])
>   ; format(user_error, '{~p is not a type}~n', [Type])
>   ).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % dnospy/1: remove spypoint
> 
> dnospy(Spec) :-
>   ( Spec = (Functor/Arity)
>   -> \+ if((current_predicate(lif,lif(_,_)),lif(lcomp(Functor,Arity,Line,_),_)),
>            (reset_ale_break(Line),fail),
>            (format(user_error,'{~p: no matching predicate}~n',[Spec]),fail)
>           )     
>   ; format(user_error, '{~p is not of the form Functor/Arity}~n', [Spec])
>   ).
> 
> dnospy_rule(Name) :-
>   \+ if((current_predicate(lrule,lrule(_,_,_,_)),lrule(Name,Line,_,_)),
>         (reset_ale_break(Line),fail),
>         (format(user_error,'{~p: no matching rule}~n',[Name]),fail)
>        ).
> 
> dnospy_lr(Name) :-
>   \+ if((current_predicate(llr,llr(_,_,_)),llr(Name,Line,_)),
> 	(reset_ale_break(Line),fail),
>         (format(user_error,'{~p: no matching lexical rule}~n',[Name]),fail)
>        ).
> 
> dnospy_lex(Word) :-
>   \+ if((current_predicate('l--->','l--->'(_,_,_,_)),'l--->'(Word,Line,_,_)),
> 	(reset_ale_break(Line),fail),
>         (format(user_error,'{~p: no matching lexical entry}~n',[Word]),fail)
>        ).
> 
> dnospy_fun(Spec) :-
>   ( Spec = (Functor/Arity)
>   -> \+ if((current_predicate('l+++>','l+++>'(_,_)),'l+++>'(lcomp(Functor,Arity,Line,_),_)),
>            (reset_ale_break(Line),fail),
> 	   (format(user_error,'{~p: no matching function declaration}~n',[Spec]),fail)
>           )
>   ; format(user_error, '{~p is not of the form Functor/Arity}~n', [Spec])
>   ).
> 
> dnospy_macro(Spec) :-
>   ( Spec = (Functor/Arity)
>   -> \+ if((current_predicate(lmacro,lmacro(_,_,_)),lmacro(Head,Line,_),functor(Head,Functor,Arity)),
>            (reset_ale_break(Line),fail),
> 	   (format(user_error,'{~p: no matching macro declaration}~n',[Spec]),fail)
>           )
>   ; format(user_error, '{~p is not of the form Functor/Arity}~n', [Spec])
>   ).
> 
> dnospy_cons(Type) :-
>   ( type(Type)
>   -> \+ if((current_predicate(lcons,lcons(_,_,_,_,_)),lcons(Type,Line,_,_,_)),
>            (reset_ale_break(Line),fail),
> 	   (format(user_error,'{no constraint for type ~p}~n',[Type]),fail)
>           )
>   ; format(user_error, '{~p is not a type}~n', [Type])
>   ).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % dskip/1: automatically skip certain components (lex. rules, empty cats
> %  etc.)
> dskip(-all) :-
>   retractall(d_skip(_)).
> dskip(+all) :-
>   dskip(+lex),
>   dskip(+empty),
>   dskip(+rule),
>   dskip(+desc),
>   dskip(+lr),
>   dskip(+fun),
>   dskip(+rel),
>   dskip(+forall),
>   dskip(+gen).
> 
> dskip(-lex) :-
>   retractall(d_skip(lex(_,_))).
> dskip(+lex) :-
>   assert(d_skip(lex(_,_))).
> 
> dskip(-empty) :-
>   retractall(d_skip(empty)),
>   retractall(d_skip(empty_close)),
>   retractall(d_skip(apply_once)).
> dskip(+empty) :-
>   assert(d_skip(empty)),
>   assert(d_skip(empty_close)),
>   assert(d_skip(apply_once)).
> 
> dskip(-rule) :-
>   retractall(d_skip(rule_close)).
> dskip(+rule) :-
>   assert(d_skip(rule_close)).
> 
> dskip(-desc) :-
>   retractall(d_skip(unify(_,_,_,_))),
>   retractall(d_skip(patheq(_,_,_,_))),
>   retractall(d_skip(ineq_add(_,_))),
>   retractall(d_skip(featval(_,_,_,_))),
>   retractall(d_skip(macro(_,_,_))),
>   retractall(d_skip(type(_,_,_,_))),
>   retractall(d_skip(atom(_,_,_,_))),
>   retractall(d_skip(fun(_,_,_,_))).
> dskip(+desc) :-
>   assert(d_skip(unify(_,_,_,_))),
>   assert(d_skip(patheq(_,_,_,_))),
>   assert(d_skip(ineq_add(_,_))),
>   assert(d_skip(featval(_,_,_,_))),
>   assert(d_skip(macro(_,_,_))),
>   assert(d_skip(type(_,_,_,_))),
>   assert(d_skip(atom(_,_,_,_))),
>   assert(d_skip(fun(_,_,_,_))).
> 
> dskip(-lr) :-
>   retractall(d_skip(lr(_,_,_))),
>   retractall(d_skip(morph_input(_,_))),
> %  retractall(d_skip(morph_output(_,_))),
>   retractall(d_skip(lrwhen)),
>   retractall(d_skip(lex_pivot_unify(_,_,_,_))).
> dskip(+lr) :-
>   assert(d_skip(lr(_,_,_))),
>   assert(d_skip(morph_input(_,_))),
> %  assert(d_skip(morph_output(_,_))),
>   assert(d_skip(lrwhen)),
>   assert(d_skip(lex_pivot_unify(_,_,_,_))).
> 
> dskip(-fun) :-
>   retractall(d_skip(fun_clause(_,_))).
> dskip(+fun) :-
>   assert(d_skip(fun_clause(_,_))).
> 
> dskip(-rel) :-
>   retractall(d_skip(comp_clause(_,_))),
>   retractall(d_skip(neg)),
>   retractall(d_skip(shallow)),
>   retractall(d_skip(exteq)),
>   retractall(d_skip(eq)),
>   retractall(d_skip(when)),
>   retractall(d_skip(prolog(_))),
>   retractall(d_skip(comp(_,_))).
> dskip(+rel) :-
>   assert(d_skip(comp_clause(_,_))),
>   assert(d_skip(neg)),
>   assert(d_skip(shallow)),
>   assert(d_skip(exteq)),
>   assert(d_skip(eq)),
>   assert(d_skip(when)),
>   assert(d_skip(prolog(_))),
>   assert(d_skip(comp(_,_))).
> 
> dskip(-forall) :-
>   retractall(d_skip(forall_rules(_,_))),
>   retractall(d_skip(forall_rule(_,_,_))),
>   retractall(d_skip(match_forall_rule_name(_,_,_))),
>   retractall(d_skip(match_forall_rule(_,_,_))),
>   retractall(d_skip(forall_lexes(_,_))),
>   retractall(d_skip(forall_lex(_,_,_))),
>   retractall(d_skip(match_forall_lex_name(_,_,_))),
>   retractall(d_skip(match_forall_lex(_,_))).  
> dskip(+forall) :-
>   assert(d_skip(forall_rules(_,_))),
>   assert(d_skip(forall_rule(_,_,_))),
>   assert(d_skip(match_forall_rule_name(_,_,_))),
>   assert(d_skip(match_forall_rule(_,_,_))),
>   assert(d_skip(forall_lexes(_,_))),
>   assert(d_skip(forall_lex(_,_,_))),
>   assert(d_skip(match_forall_lex_name(_,_,_))),
>   assert(d_skip(match_forall_lex(_,_))).
> 
> dskip(-gen) :-
>   retractall(d_skip(sem_index(_,_,_))),
>   retractall(d_skip(pivot_tmpl(_,_,_))),
>   retractall(d_skip(pivot_find(_,_,_))),
>   retractall(d_skip(pivot_lex(_,_,_))),
>   retractall(d_skip(pivot_empty(_,_))),
>   retractall(d_skip(pivot_ncrule(_,_,_))),
>   retractall(d_skip(chain_crule(_,_,_,_,_,_))),
>   retractall(d_skip(chain_check(_,_,_,_,_))),
>   retractall(d_skip(pivot_gen(_,_,_,_,_))),
>   retractall(d_skip(pre_chain_gen(_,_,_,_,_,_,_))),
>   retractall(d_skip(post_chain_gen(_,_,_,_,_,_,_,_))),
>   retractall(d_skip(pivot_conn(_,_,_,_,_,_,_,_,_))),
>   retractall(d_skip(new_chain_conn(_,_,_,_,_,_,_,_,_,_))),
>   retractall(d_skip(root_chain_unify(_,_,_,_,_))).
> dskip(+gen) :-
>   assert(d_skip(sem_index(_,_,_))),
>   assert(d_skip(pivot_tmpl(_,_,_))),
>   assert(d_skip(pivot_find(_,_,_))),
>   assert(d_skip(pivot_lex(_,_,_))),
>   assert(d_skip(pivot_empty(_,_))),
>   assert(d_skip(pivot_ncrule(_,_,_))),
>   assert(d_skip(chain_crule(_,_,_,_,_,_))),
>   assert(d_skip(chain_check(_,_,_,_,_))),
>   assert(d_skip(pivot_gen(_,_,_,_,_))),
>   assert(d_skip(pre_chain_gen(_,_,_,_,_,_,_))),
>   assert(d_skip(post_chain_gen(_,_,_,_,_,_,_,_))),
>   assert(d_skip(pivot_conn(_,_,_,_,_,_,_,_,_))),
>   assert(d_skip(new_chain_conn(_,_,_,_,_,_,_,_,_,_))),
>   assert(d_skip(root_chain_unify(_,_,_,_,_))).
> 
> ale_dskip(Command) :-
>   current_predicate(d_skip,d_skip(_)),
>   d_skip(Command).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % dleash/1:  leashing control on components
> dleash(+all) :-
>   retractall(ale_no_leash(_)).
> dleash(-all) :-
>   dleash(-empty),
>   dleash(-lex),
>   dleash(-desc),
>   dleash(-lr),
>   dleash(-fun),
>   dleash(-rel),
>   dleash(-rule),
>   dleash(-forall),
>   dleash(-gen).
> 
> dleash(+empty) :-
>   retractall(ale_no_leash(empty)),
>   retractall(ale_no_leash(empty_close)),
>   retractall(ale_no_leahs(apply_once)).
> dleash(-empty) :-
>   assert(ale_no_leash(empty)),
>   assert(ale_no_leash(empty_close)),
>   assert(ale_no_leash(apply_once)).
> 
> dleash(+lex) :-
>   retractall(ale_no_leash(lex(_,_))).
> dleash(-lex) :-
>   assert(ale_no_leash(lex(_,_))).
> 
> dleash(+desc) :-
>   retractall(ale_no_leash(unify(_,_,_,_))),
>   retractall(ale_no_leash(patheq(_,_,_,_))),
>   retractall(ale_no_leash(ineq_add(_,_))),
>   retractall(ale_no_leash(featval(_,_,_))),
>   retractall(ale_no_leash(macro(_,_))),
>   retractall(ale_no_leash(type(_,_,_))),
>   retractall(ale_no_leash(atom(_,_,_))),
>   retractall(ale_no_leash(fun(_,_,_))).
> dleash(-desc) :-
>   assert(ale_no_leash(unify(_,_,_,_))),
>   assert(ale_no_leash(patheq(_,_,_,_))),
>   assert(ale_no_leash(ineq_add(_,_))),
>   assert(ale_no_leash(featval(_,_,_))),
>   assert(ale_no_leash(macro(_,_))),
>   assert(ale_no_leash(type(_,_,_))),
>   assert(ale_no_leash(atom(_,_,_))),
>   assert(ale_no_leash(fun(_,_,_))).
> 
> dleash(+lr) :-
>   retractall(ale_no_leash(lr(_,_,_))),
>   retractall(ale_no_leash(morph_input(_,_))),
> %  retractall(ale_no_leash(morph_output(_,_))),
>   retractall(ale_no_leash(lrwhen)),
>   retractall(ale_no_leash(lex_pivot_unify(_,_,_,_))).
> dleash(-lr) :-
>   assert(ale_no_leash(lr(_,_,_))),
>   assert(ale_no_leash(morph_input(_,_))),
> %  assert(ale_no_leash(morph_output(_,_))),
>   assert(ale_no_leash(lrwhen)),
>   assert(ale_no_leash(lex_pivot_unify(_,_,_,_))).
> 
> dleash(+fun) :-
>   retractall(ale_no_leash(fun_clause(_,_))).
> dleash(-fun) :-
>   assert(ale_no_leash(fun_clause(_,_))).
> 
> dleash(+rel) :-
>   retractall(ale_no_leash(comp_clause(_,_))),
>   retractall(ale_no_leash(neg)),
>   retractall(ale_no_leash(shallow)),
>   retractall(ale_no_leash(exteq)),
>   retractall(ale_no_leash(eq)),
>   retractall(ale_no_leash(when)),
>   retractall(ale_no_leash(prolog(_))),
>   retractall(ale_no_leash(comp(_,_))).
> dleash(-rel) :-
>   assert(ale_no_leash(comp_clause(_,_))),
>   assert(ale_no_leash(neg)),
>   assert(ale_no_leash(shallow)),
>   assert(ale_no_leash(exteq)),
>   assert(ale_no_leash(eq)),
>   assert(ale_no_leash(when)),
>   assert(ale_no_leash(prolog(_))),
>   assert(ale_no_leash(comp(_,_))).
> 
> dleash(+rule) :-
>   retractall(ale_no_leash(rule_close)),
>   retractall(ale_no_leash(rule(_))).
> dleash(-rule) :-
>   assert(ale_no_leash(rule_close)),
>   assert(ale_no_leash(rule(_))).
> 
> dleash(+forall) :-
>   retractall(ale_no_leash(forall_rules(_,_))),
>   retractall(ale_no_leash(forall_rule(_,_,_))),
>   retractall(ale_no_leash(match_forall_rule_name(_,_,_))),
>   retractall(ale_no_leash(match_forall_rule(_,_,_))),
>   retractall(ale_no_leash(forall_lexes(_,_))),
>   retractall(ale_no_leash(forall_lex(_,_,_))),
>   retractall(ale_no_leash(match_forall_lex_name(_,_,_))),
>   retractall(ale_no_leash(match_forall_lex(_,_))).
> dleash(-forall) :-
>   assert(ale_no_leash(forall_rules(_,_))),
>   assert(ale_no_leash(forall_rule(_,_,_))),
>   assert(ale_no_leash(match_forall_rule_name(_,_,_))),
>   assert(ale_no_leash(match_forall_rule(_,_,_))),
>   assert(ale_no_leash(forall_lexes(_,_))),
>   assert(ale_no_leash(forall_lex(_,_,_))),
>   assert(ale_no_leash(match_forall_lex_name(_,_,_))),
>   assert(ale_no_leash(match_forall_lex(_,_))).
> 
> dleash(+gen) :-
>   retractall(ale_no_leash(sem_index(_,_,_))),
>   retractall(ale_no_leash(pivot_tmpl(_,_,_))),
>   retractall(ale_no_leash(pivot_find(_,_,_))),
>   retractall(ale_no_leash(pivot_lex(_,_,_))),
>   retractall(ale_no_leash(pivot_empty(_,_))),
>   retractall(ale_no_leash(pivot_ncrule(_,_,_))),
>   retractall(ale_no_leash(chain_crule(_,_,_,_,_,_))),
>   retractall(ale_no_leash(chain_check(_,_,_,_,_))),
>   retractall(ale_no_leash(pivot_gen(_,_,_,_,_))),
>   retractall(ale_no_leash(pre_chain_gen(_,_,_,_,_,_,_))),
>   retractall(ale_no_leash(post_chain_gen(_,_,_,_,_,_,_,_))),
>   retractall(ale_no_leash(pivot_conn(_,_,_,_,_,_,_,_,_))),
>   retractall(ale_no_leash(new_chain_conn(_,_,_,_,_,_,_,_,_,_))),
>   retractall(ale_no_leash(root_chain_unify(_,_,_,_,_))).
> dleash(-gen) :-
>   assert(ale_no_leash(sem_index(_,_,_))),
>   assert(ale_no_leash(pivot_tmpl(_,_,_))),
>   assert(ale_no_leash(pivot_find(_,_,_))),
>   assert(ale_no_leash(pivot_lex(_,_,_))),
>   assert(ale_no_leash(pivot_empty(_,_))),
>   assert(ale_no_leash(pivot_ncrule(_,_,_))),
>   assert(ale_no_leash(chain_crule(_,_,_,_,_,_))),
>   assert(ale_no_leash(chain_check(_,_,_,_,_))),
>   assert(ale_no_leash(pivot_gen(_,_,_,_,_))),
>   assert(ale_no_leash(pre_chain_gen(_,_,_,_,_,_,_))),
>   assert(ale_no_leash(post_chain_gen(_,_,_,_,_,_,_,_))),
>   assert(ale_no_leash(pivot_conn(_,_,_,_,_,_,_,_,_))),
>   assert(ale_no_leash(new_chain_conn(_,_,_,_,_,_,_,_,_,_))),
>   assert(ale_no_leash(root_chain_unify(_,_,_,_,_))).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Meta-interpretation
> 
> % meta-interpret Goal within a box labelled Port, corresponding to
> % source-line Line
> d_meta_interp(PortCommand,Line,Goal) :-
>   d_meta_interp(PortCommand,Line,Goal,false).
> 
> d_meta_interp(PortCommand,Line,Goal,Retrying) :-
>   (Retrying -> true ; announce_step(PortCommand,Line,StepID)),
>   on_exception(ale_retry,
>     (d_call_fail(PortCommand,Line),
>     on_exception(ale_fail,
>       (call_det(Goal,DetFlag),
>        d_exit_redo(StepID,PortCommand,Line,DetFlag)),
>     fail)),
>   d_meta_interp(PortCommand,Line,Goal,true)),
>   (DetFlag==true -> ! ; true).
> 
> :- meta_predicate call_det(:,?).
> % call Goal.  If it succeeds deterministically, Det is true,
> %  otherwise Det is false.
> call_det(Goal, Det) :-
>         CH1 is 'IF FUNCTION',  % this is the B pointer into the call stack
>         call(Goal),
>         CH2 is 'IF FUNCTION',
>         (   CH1=:=CH2 -> Det = true
>         ;   Det = false
>         ).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Announcement of parsing steps
> 
> :- dynamic last_step_id/1.
> 
> clear_hook :-
>   retractall(last_step_id(_)),
>   asserta(last_step_id(0)).
> 
> announce_parse_begin(Words) :-
>   current_predicate(announce_parse_begin_hook,announce_parse_begin_hook(_)) ->
>     call_all(announce_parse_begin_hook(Words)) ;
>     true.
> 
> announce_step(Command,Line,StepID) :-
>   parsing(_) -> (
>     retract(last_step_id(OldStepID)),
>     StepID is OldStepID + 1,
>     asserta(last_step_id(StepID)),
>     current_predicate(announce_step_hook,announce_step_hook(_,_,_)) ->
>       call_all(announce_step_hook(StepID,Command,Line)) ;
>       true
>   ) ; true.
> 
> announce_call :-
>   write('_annb_'), (parsing(_) -> (
>     current_predicate(announce_call_hook,announce_call_hook) ->
>       call_all(announce_call_hook) ; true
>   ) ; true.), write('_anne_').
> 
> announce_fail :-
>   parsing(_) -> (
>     current_predicate(announce_fail_hook,announce_fail_hook) ->
>       call_all(announce_fail_hook) ; true
>   ) ; true.
> 
> announce_exit :-
>   parsing(_) -> (
>     current_predicate(announce_exit_hook,announce_exit_hook) ->
>       call_all(announce_exit_hook) ; true
>   ) ; true.
> 
> announce_redo(StepID) :-
>   parsing(_) -> (
>     current_predicate(announce_redo_hook,announce_redo_hook(_)) ->
>       call_all(announce_redo_hook(StepID)) ; true
>   ) ; true.
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Call and Fail ports
> d_call_fail(Command,Line) :-
>   d_skip_level(Skip) ->  % need shallow cut for buggy Win32 SICStus
>   
> %    write(user_error,'call port: '), %DEBUG
> %    functor(Command,CFunc,_),
> %    write(user_error,CFunc), write(user_error,' '),
> %    write(user_error,Skip),
> %    nl(user_error), flush_output(user_error),
> %    ((CFunc == featval,Skip==10046) -> trace ; true),
>   
>     d_mode(Mode),
>     write('b'),
>     announce_call,
>     write('a'),
>     display_and_ask_call(Mode,Command,Line,Skip),
>     NewSkip is Skip + 1,
>     set_d_skip_level(NewSkip).
> d_call_fail(Command,Line) :-
>   retract(d_skip_level(Skip)) -> % need shallow cut for buggy Win32 SICStus
>     OldSkip is Skip - 1,
>     asserta(d_skip_level(OldSkip)),  % need asserta/1 for buggy Win32 SICStus
>     d_mode(Mode),
> 
> %    write(user_error,'fail port: '), % DEBUG
> %    functor(Command,CFunc,_),
> %    write(user_error,CFunc), write(user_error,' '),
> %    write(user_error,OldSkip),
> %    nl(user_error), flush_output(user_error),
> 
>     announce_fail,
>     display_and_ask_fail(Mode,OldSkip,Command,Line).
> 
> % integrity. % :- d_skip_level(_),!.
> %integrity :-  % DEBUG
> %  retractall(integrity(_)),
> %  retractall(intlevel(_)),
> %  assert(integrity(0)),
> %  int_act.
> %int_act :-
> %  d_skip_level(S),
> %  retract(integrity(I)),
> %  NewI is I + 1,
> %  assert(integrity(NewI)),
> %  assert(intlevel(S)),
> %  fail.
> %int_act :-
> %  retract(integrity(I)),
> %  (I > 1 -> ( write(user_error,'integrity violation: '),
> %              retract(intlevel(S)),
> %              write(user_error,S),write(user_error,' '),
> %              fail
> %	    ; nl(user_error), flush_output(user_error), f
> %	    )
> %  ; true
> %  ).
> 
> display_and_ask_call(skip(_),_,_,_).
> display_and_ask_call(leap,Command,Line,Skip) :-
>   ((current_predicate(ale_break,ale_break(_)),ale_break(Line)) ->
>     retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_ask(call,Command,Line),
>     (ale_dskip(Command) ->
>       write('<auto-skip>'),nl,ttyflush,
>       retract(d_mode(_)),
>       assert(d_mode(skip(Skip)))
>     ; (ale_leash(Command) ->
>         get_reply(Reply),
>         dac_act(Reply,Skip,Command,Line)
>       ; nl,ttyflush,
>         true))
>   ; true).
> display_and_ask_call(line(LeapLine),Command,Line,Skip) :-
>   ((LeapLine == Line) -> true
>   ; retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_ask(call,Command,Line),
>     (ale_dskip(Command) ->
>       write('<auto-skip>'),nl,ttyflush,
>       retract(d_mode(_)),
>       assert(d_mode(skip(Skip)))
>     ; (ale_leash(Command) ->
>         get_reply(Reply),
>         dac_act(Reply,Skip,Command,Line)
>       ; nl,ttyflush,
>         true))).
> display_and_ask_call(creep,Command,Line,Skip) :-
>   d_ask(call,Command,Line),
>   (ale_dskip(Command) ->
>     write('<auto-skip>'),nl,ttyflush,
>     retract(d_mode(_)),
>     assert(d_mode(skip(Skip)))
>   ; (ale_leash(Command) ->
>       get_reply(Reply),
>       dac_act(Reply,Skip,Command,Line)
>     ; nl,ttyflush,
>       true)).
> 
> dac_act(97,_,_,_) :-       % (a)bort
>   abort.
> dac_act(102,_,_,_) :-      % (f)ail
>   !,
>   fail.
> dac_act(108,_,_,_) :- % (l)eap
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(leap)).
> dac_act(99,_,_,_) :-  % (c)reep
>   !.
> dac_act(115,Skip,_,_) :-   % (s)kip
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(skip(Skip))).
> dac_act(110,_,_,Line) :-   % li(n)e
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(line(Line))). 
> dac_act(100,Skip,Command,Line) :-  % (d)isplay current FS
>   !,
>   display_current(Command),
>   display_and_ask_call(creep,Command,Line,Skip).
> dac_act(43,Skip,Command,Line) :-        % +: set spypoint
>   !,
>   set_ale_break(Line),
>   display_and_ask_call(creep,Command,Line,Skip).
> dac_act(45,Skip,Command,Line) :-        % -: remove spypoint
>   !,
>   reset_ale_break(Line),
>   display_and_ask_call(creep,Command,Line,Skip).
> dac_act(105,Skip,Command,Line) :-      % toggle chart (i)nterpreter
>   !,
>   (no_interpreter ->
>     interp
>   ; nointerp),
>   ttyflush,
>   display_and_ask_call(creep,Command,Line,Skip).
> dac_act(64,Skip,Command,Line) :-       % @: command from user/emacs
>   !,read(Goal),
>   if(call(Goal),
>      true,
>      (write(no),nl)),  % don't let Goal failure cause failure in trace
>   nl,nl,ttyflush,
>   write('Call:'),write_command(Command),write('? '),ttyflush,
>   get_reply(Reply),
>   dac_act(Reply,Skip,Command,Line).
> dac_act(10,_,_,_) :-  % LFD (same as creep)
>   !.
> dac_act(104,Skip,Command,Line) :-       % (h)elp
>   !,
>   nl,write('Call port commands:'),nl,
>   write('(a)bort     (l)eap'),nl,
>   write('(LF/c)reep  li(n)e'),nl,
>   write('(f)ail      (s)kip'),nl,
>   write(' toggle chart (i)nterpreter'),nl,
>   write(' (d)isplay current structure'),nl,
>   write(' @ <prolog_goal>.: pass goal to Prolog'),nl,
>   write(' +: set breakpoint'),nl,
>   write(' -: clear breakpoint'),nl,
>   write('(?/h)elp'),nl,
>   ttyflush,
>   display_and_ask_call(creep,Command,Line,Skip).
> dac_act(63,Skip,Command,Line) :-        % ?: help also
>   !,dac_act(104,Skip,Command,Line).
> dac_act(_,Skip,Command,Line) :-     % everything else - try again
>   write(user_error,'Invalid Response (? or h for help)'),nl(user_error),
>   flush_output(user_error),
>   display_and_ask_call(creep,Command,Line,Skip).
> 
> display_and_ask_fail(skip(Skip),Skip,Command,Line) :-
>   !,retract(d_mode(_)),
>   assert(d_mode(creep)),
>   d_ask(fail,Command,Line),
>   (ale_dskip(Command) ->
>     write('<auto-skipped>'),nl,ttyflush,
>     fail
>   ; (ale_leash(Command) ->
>       get_reply(Reply),
>       daf_act(Reply,Skip,Command,Line)
>     ; nl,ttyflush,
>       fail)).
> display_and_ask_fail(skip(_),_,_,_) :-
>   fail.
> display_and_ask_fail(leap,Skip,Command,Line) :-
>   ((current_predicate(ale_break,ale_break(_)),ale_break(Line)) ->
>     retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_ask(fail,Command,Line),
>     (ale_leash(Command) ->
>       get_reply(Reply),
>       daf_act(Reply,Skip,Command,Line)
>     ; nl,ttyflush,
>       fail)
>   ; fail).
> display_and_ask_fail(line(LeapLine),Skip,Command,Line) :-
>   ((LeapLine == Line) ->
>     fail
>   ; retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_ask(fail,Command,Line),
>     (ale_leash(Command) ->
>       get_reply(Reply),
>       daf_act(Reply,Skip,Command,Line)
>     ; nl,ttyflush,
>       fail)).
> display_and_ask_fail(creep,Skip,Command,Line) :-
>   d_ask(fail,Command,Line),
>   (ale_leash(Command) ->
>     get_reply(Reply),
>     daf_act(Reply,Skip,Command,Line)
>   ; nl,ttyflush,
>     fail).
> 
> daf_act(97,_,_,_) :-       % (a)bort
>   abort.
> daf_act(108,_,_,_) :- % (l)eap
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(leap)),
>   fail.
> daf_act(99,_,_,_) :-  % (c)reep
>   !,
>   fail.
> daf_act(114,_,_,_) :- % (r)etry
>   !,
>   raise_exception(ale_retry).
> daf_act(10,_,_,_) :-                    % LFD (same as creep)
>   !,fail.
> daf_act(110,_,_,Line) :-                % li(n)e
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(line(Line))),
>   fail.
> daf_act(100,Skip,Command,Line) :-  % (d)isplay current FS
>   !,
>   display_current(Command),
>   display_and_ask_fail(creep,Skip,Command,Line).
> daf_act(43,Skip,Command,Line) :-    % +: set spypoint
>   !,
>   set_ale_break(Line),
>   display_and_ask_fail(creep,Skip,Command,Line).
> daf_act(45,Skip,Command,Line) :-    % -: remove spypoint
>   !,
>   reset_ale_break(Line),
>   display_and_ask_fail(creep,Skip,Command,Line).
> daf_act(105,Skip,Command,Line) :-      % toggle chart (i)nterpreter
>   !,
>   (no_interpreter ->
>     interp
>   ; nointerp),
>   ttyflush,
>   display_and_ask_fail(creep,Skip,Command,Line).
> daf_act(64,Skip,Command,Line) :-       % @: command from user/emacs
>   !,read(Goal),
>   if(call(Goal),
>      true,
>      (write(no),nl)),  % don't let Goal failure cause failure in trace
>   nl,nl,ttyflush,
>   write('Fail:'),write_command(Command),write('? '),ttyflush,
>   get_reply(Reply),
>   daf_act(Reply,Skip,Command,Line).
> daf_act(104,Skip,Command,Line) :-       % (h)elp
>   !,
>   nl,write('Fail port commands:'),nl,
>   write('(a)bort     (l)eap'),nl,
>   write('(LF/c)reep  li(n)e'),nl,
>   write('            (r)etry'),nl,
>   write(' toggle chart (i)nterpreter'),nl,
>   write(' (d)isplay current structure'),nl,
>   write(' @ <prolog_goal>.: pass goal to Prolog'),nl,
>   write(' +: set breakpoint'),nl,
>   write(' -: clear breakpoint'),nl,
>   write('(?/h)elp'),nl,
>   ttyflush,
>   display_and_ask_fail(creep,Skip,Command,Line).
> daf_act(63,Skip,Command,Line) :-        % ?: help also
>   !,daf_act(104,Skip,Command,Line).
> daf_act(_,Skip,Command,Line) :-     % everything else - try again
>   write(user_error,'Invalid Response (? or h for help)'),nl(user_error),
>   flush_output(user_error),
>   display_and_ask_fail(creep,Skip,Command,Line).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Exit and Redo ports
> d_exit_redo(_,Command,Line,DetFlag) :-
>   d_mode(Mode),
>   (d_skip_level(Skip) -> % need shallow cut for buggy Win32 SICStus
>      OldSkip is Skip - 1,
>   
> %     write(user_error,'exit port: '), %DEBUG
> %     functor(Command,CFunc,_),
> %     write(user_error,CFunc), write(user_error,' '),
> %     write(user_error,OldSkip),
> %     nl(user_error), flush_output(user_error),
> 
>      announce_exit,
>      display_and_ask_exit(Mode,OldSkip,Command,Line,DetFlag),
>      set_d_skip_level(OldSkip)
>   ).
> d_exit_redo(StepID,Command,Line,_) :-
>   d_mode(Mode),
>   (retract(d_skip_level(Skip)) -> % need shallow cut for buggy Win32 SICStus
> 
> %   write(user_error,'redo port: '), %DEBUG
> %   functor(Command,CFunc,_),
> %   write(user_error,CFunc), write(user_error,' '),
> %   write(user_error,Skip),
> %   nl(user_error), flush_output(user_error),
>     
>    NewSkip is Skip + 1,
>    asserta(d_skip_level(NewSkip)), % need asserta/1 for buggy Win32 SICStus
>    announce_step(StepID,Command,Line),
>    announce_redo,
>    display_and_ask_redo(Mode,Command,Line,Skip)
>   ).
> 
> display_and_ask_exit(skip(Skip),Skip,Command,Line,DetFlag) :-
>   !,retract(d_mode(_)),
>   assert(d_mode(creep)),
>   d_ask(exit(DetFlag),Command,Line),
>   (ale_dskip(Command) ->
>     write('<auto-skipped>'),nl,ttyflush
>   ; (ale_leash(Command) ->
>       get_reply(Reply),
>       dae_act(Reply,Skip,Command,Line,DetFlag)
>     ; nl,ttyflush,
>       true)).
> display_and_ask_exit(skip(_),_,_,_,_).
> display_and_ask_exit(leap,Skip,Command,Line,DetFlag) :-
>   ((current_predicate(ale_break,ale_break(_)),ale_break(Line)) ->
>     retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_ask(exit(DetFlag),Command,Line),
>     (ale_leash(Command) ->
>       get_reply(Reply),
>       dae_act(Reply,Skip,Command,Line,DetFlag)
>     ; nl,ttyflush,
>       true)
>   ; true).
> display_and_ask_exit(line(LeapLine),Skip,Command,Line,DetFlag) :-
>   ((LeapLine == Line) -> true
>   ; retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_ask(exit(DetFlag),Command,Line),
>     (ale_leash(Command) ->
>       get_reply(Reply),
>       dae_act(Reply,Skip,Command,Line,DetFlag)
>     ; nl,ttyflush,
>       true)).
> display_and_ask_exit(creep,Skip,Command,Line,DetFlag) :-
>   d_ask(exit(DetFlag),Command,Line),
>   (ale_leash(Command) ->
>     get_reply(Reply),
>     dae_act(Reply,Skip,Command,Line,DetFlag)
>   ; nl,ttyflush,
>     true).
> 
> dae_act(97,_,_,_,_) :-       % (a)bort
> write(oha),
>   abort.
> dae_act(102,_,_,_,_) :-      % (f)ail
>   !,
>   raise_exception(ale_fail).
> dae_act(108,_,_,_,_) :-   % (l)eap
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(leap)).
> dae_act(99,_,_,_,_) :-       % (c)reep
>   !.
> dae_act(114,_,_,_,_) :- % (r)etry
>   !,
>   raise_exception(ale_retry).
> dae_act(10,_,_,_,_) :-       % LFD (same as creep)
>   !.
> dae_act(110,_,_,Line,_) :-   % li(n)e
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(line(Line))).
> dae_act(100,Skip,Command,Line,DetFlag) :-   % (d)isplay current FS
>   !,
>   display_current(Command),
>   display_and_ask_exit(creep,Skip,Command,Line,DetFlag).
> dae_act(43,Skip,Command,Line,DetFlag) :-    % +: set spypoint
>   !,
>   set_ale_break(Line),
>   display_and_ask_exit(creep,Skip,Command,Line,DetFlag).
> dae_act(45,Skip,Command,Line,DetFlag) :-    % -: remove spypoint
>   !,
>   reset_ale_break(Line),
>   display_and_ask_exit(creep,Skip,Command,Line,DetFlag).
> dae_act(105,Skip,Command,Line,DetFlag) :-      % toggle chart (i)nterpreter
>   !,
>   (no_interpreter ->
>     interp
>   ; nointerp),
>   ttyflush,
>   display_and_ask_exit(creep,Skip,Command,Line,DetFlag).
> dae_act(64,Skip,Command,Line,DetFlag) :-       % @: command from user/emacs
>   !,read(Goal),
>   if(call(Goal),
>      true,
>      (write(no),nl)),  % don't let Goal failure cause failure in trace
>   nl,nl,ttyflush,
>   write('Exit:'),write_command(Command),write('? '),ttyflush,
>   get_reply(Reply),
>   dae_act(Reply,Skip,Command,Line,DetFlag).
> dae_act(104,Skip,Command,Line,DetFlag) :-       % (h)elp
>   !,
>   nl,write('Exit port commands:'),nl,
>   write('(a)bort     (l)eap'),nl,
>   write('(LF/c)reep  li(n)e'),nl,
>   write('(f)ail      (r)etry'),nl,
>   write(' toggle chart (i)nterpreter'),nl,
>   write(' (d)isplay current structure'),nl,
>   write(' @ <prolog_goal>.: pass goal to Prolog'),nl,
>   write(' +: set breakpoint'),nl,
>   write(' -: clear breakpoint'),nl,
>   write('(?/h)elp'),nl,
>   ttyflush,
>   display_and_ask_exit(creep,Skip,Command,Line,DetFlag).
> dae_act(63,Skip,Command,Line,DetFlag) :-        % ?: help also
>   !,dae_act(104,Skip,Command,Line,DetFlag).
> dae_act(_,Skip,Command,Line,DetFlag) :-   % everything else - try again
>   write(user_error,'Invalid Response (? or h for help)'),nl(user_error),
>   flush_output(user_error),
>   display_and_ask_exit(creep,Skip,Command,Line,DetFlag).
> 
> display_and_ask_redo(skip(_),_,_,_) :-
>   fail.
> display_and_ask_redo(leap,Command,Line,Skip) :-
>   ((current_predicate(ale_break,ale_break(_)),ale_break(Line)) ->
>     retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_ask(redo,Command,Line),
>     (ale_dskip(Command) ->
>       write('<auto-skip>'),nl,ttyflush,
>       retract(d_mode(_)),
>       assert(d_mode(skip(Skip))),
>       fail
>     ; (ale_leash(Command) ->
>         get_reply(Reply),
>         dar_act(Reply,Skip,Command,Line)
>       ; nl,ttyflush,
>         fail))
>   ; fail).
> display_and_ask_redo(line(LeapLine),Command,Line,Skip) :-
>   ((LeapLine == Line) ->
>     fail
>   ; retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_ask(redo,Command,Line),
>     (ale_dskip(Command) ->
>       write('<auto-skip>'),nl,ttyflush,
>       retract(d_mode(_)),
>       assert(d_mode(skip(Skip))),
>       fail
>     ; (ale_leash(Command) ->
>         get_reply(Reply),
>         dar_act(Reply,Skip,Command,Line)
>       ; nl,ttyflush,
>         fail))).
> display_and_ask_redo(creep,Command,Line,Skip) :-
>   d_ask(redo,Command,Line),
>   (ale_dskip(Command) ->
>     write('<auto-skip>'),nl,ttyflush,
>     retract(d_mode(_)),
>     assert(d_mode(skip(Skip))),
>     fail
>   ; (ale_leash(Command) ->
>       get_reply(Reply),
>       dar_act(Reply,Skip,Command,Line)
>     ; nl,ttyflush,
>       fail)).
> 
> dar_act(97,_,_,_) :-    % (a)bort
>   abort.
> dar_act(102,_,_,_) :-   % (f)ail
>   !,
>   raise_exception(ale_fail).
> dar_act(108,_,_,_) :-   % (l)eap
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(leap)),
>   fail.
> dar_act(99,_,_,_) :-       % (c)reep
>   !,
>   fail.
> dar_act(114,_,_,_) :- % (r)etry
>   !,
>   raise_exception(ale_retry).
> dar_act(115,Skip,_,_) :-   % (s)kip
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(skip(Skip))),
>   fail.
> dar_act(10,_,_,_) :-       % LFD (same as creep)
>   !,fail.
> dar_act(110,_,_,Line) :-   % li(n)e
>   !,
>   retract(d_mode(_)),
>   assert(d_mode(line(Line))),
>   fail.
> dar_act(100,Skip,Command,Line) :-   % (d)isplay current FS
>   !,
>   display_current(Command),
>   display_and_ask_redo(creep,Command,Line,Skip).
> dar_act(43,Skip,Command,Line) :-    % +: set spypoint
>   !,
>   set_ale_break(Line),
>   display_and_ask_redo(creep,Command,Line,Skip).
> dar_act(45,Skip,Command,Line) :-    % -: remove spypoint
>   !,
>   reset_ale_break(Line),
>   display_and_ask_redo(creep,Command,Line,Skip).
> dar_act(105,Skip,Command,Line) :-      % toggle chart (i)nterpreter
>   !,
>   (no_interpreter ->
>     interp
>   ; nointerp),
>   ttyflush,
>   display_and_ask_redo(creep,Command,Line,Skip).
> dar_act(64,Skip,Command,Line) :-       % @: command from user/emacs
>   !,read(Goal),
>   if(call(Goal),
>      true,
>      (write(no),nl)),  % don't let Goal failure cause failure in trace
>   nl,nl,ttyflush,
>   write('Redo:'),write_command(Command),write('? '),ttyflush,
>   get_reply(Reply),
>   dar_act(Reply,Skip,Command,Line).
> dar_act(104,Skip,Command,Line) :-       % (h)elp
>   !,
>   nl,write('Redo port commands:'),nl,
>   write('(a)bort     (l)eap'),nl,
>   write('(LF/c)reep  li(n)e'),nl,
>   write('(f)ail      (s)kip'),nl,
>   write('(r)etry'),nl,
>   write(' toggle chart (i)nterpreter'),nl,
>   write(' (d)isplay current structure'),nl,
>   write(' @ <prolog_goal>.: pass goal to Prolog'),nl,
>   write(' +: set breakpoint'),nl,
>   write(' -: clear breakpoint'),nl,
>   write('(?/h)elp'),nl,
>   ttyflush,
>   display_and_ask_redo(creep,Command,Line,Skip).
> dar_act(63,Skip,Command,Line) :-        % ?: help also
>   !,dar_act(104,Skip,Command,Line).
> dar_act(_,Skip,Command,Line) :-    % everything else - try again
>   write(user_error,'Invalid Response (? or h for help)'),nl(user_error),
>   flush_output(user_error),
>   display_and_ask_redo(creep,Command,Line,Skip).
>   
> % gg_reply(-Reply)
> %   Called when waiting at a step to get the reply of the user or the steering
> %   application. If the hook gg_reply/1 is defined, it will be used. If not,
> %   the default strategy (read one character from the terminal) will be used.
> get_reply(Reply) :-
>   current_predicate(get_reply_hook, get_reply_hook(_))
>   -> get_reply_hook(Reply)
>    ; get_code(Reply),
>      (Reply =:= 10
>       -> true
>        ; skip_line).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Un/block ports
> d_blocked(LBody,Line) :-
>   d_mode(Mode),
>   display_blocked(Mode,Line,LBody).
> 
> d_blocked_act(LBody) :-  
>   left_functor(LBody,Functor,Arity,Dots),
>   write('Blocked: '),write(Functor),write('/'),write(Arity),write(Dots),
>   nl,ttyflush.
> 
> display_blocked(skip(_),_,_).
> display_blocked(leap,Line,LBody) :-
>   ((current_predicate(ale_break,ale_break(_)),ale_break(Line)) ->
>     retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_blocked_act(LBody)
>   ; true
>   ).
> display_blocked(line(LeapLine),Line,LBody) :-
>   ((LeapLine == Line) -> true
>   ; retract(d_mode(_)),
>     assert(d_mode(creep)),
>     d_blocked_act(LBody)
>   ).
> display_blocked(creep,_,LBody) :-
>   d_blocked_act(LBody).
> 
> d_unblocked(LBody) :-
>   d_mode(Mode),
>   display_unblocked(Mode,LBody).
> 
> d_unblocked_act(LBody) :-	
>   left_functor(LBody,Functor,Arity,Dots),
>   write('Unblocked: '),write(Functor),write('/'),write(Arity),write(Dots),
>   nl,ttyflush.
> 
> display_unblocked(skip(_),_).
> display_unblocked(leap,_).
> display_unblocked(line(_),LBody) :-
>   d_unblocked_act(LBody).
> display_unblocked(creep,LBody) :-
>   d_unblocked_act(LBody).
> 
> 
> left_functor((G,_),Functor,Arity,',...') :-
>   left_functor(G,Functor,Arity,_).
> left_functor((G;_),Functor,Arity,';...') :-
>   left_functor(G,Functor,Arity,_).
> left_functor(lneg(_,_),'\+',1,'').
> left_functor(lexteq(_,_,_),'=@',2,'').
> left_functor(lunify(_,_,_),'=',2,'').
> left_functor(lwhen(_,_,_),'when',2,'').
> left_functor(ltrue,true,0,'').
> left_functor(lfail,fail,0,'').
> left_functor(lcut,!,0,'').
> left_functor(lshallow(_,_,_,_),'->',3,'').
> left_functor(lprolog(_,_),prolog,1,'').
> left_functor(lprolog(_,_,_),prolog,2,'').
> left_functor(lcomp(Functor,Arity,_,_),Functor,Arity,'').
> 	
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % d_ask/3: Query user at Port about Command at source-file line Line
> 
> d_ask(Port,Command,Line) :-
> %    ale_debugging(AbsFile),
>     ((Line = []) -> true
>     ; % LineFrom1 is Line + 1,
>       Line = [AbsFile|LineNo],
>       emacs_format(user_error,'$([{u~n$)]}~n$([{f,null,~w,~a~n$)]}~n',
>                    [LineNo,AbsFile]),
>       flush_output(user_error)),
>     write_port(Port,Command),write_command(Command),write('? '),ttyflush.
> 
> write_port(call,_Command) :-
>   write('Call:').
> write_port(fail,Command) :-
>   failure_driven(Command)
>   -> write('Finished:')
>    ; write('Fail:').
> write_port(redo,_Command) :-
>   write('Redo:').
> write_port(exit(DetFlag),_Command) :-
>   (DetFlag==false -> write('? ') ; true),
>   write('Exit:').
> 
> failure_driven(rule_close).
> 
> write_command(unify(Loc,XName,_,_)) :-
>   write('unify '),write_loc(Loc),write(' with '),write(XName).
> write_command(patheq(Loc,Path1,Path2,_)) :-
>   write('path equate '),write(Path1),write(' with '),write(Path2),
>   write(' at '),write_loc(Loc).
> write_command(ineq_add(Loc,_)) :-
>   write('inequate '),write_loc(Loc),write(' with description').
> write_command(featval(Loc,Feat,_)) :-
>   write('enforce description on '),write(Feat),write(' value of '),
>   write_loc(Loc).
> write_command(macro(MacroName,_)) :-
>   functor(MacroName,Functor,Arity),
>   write('substitute macro description for '),write(Functor),write('/'),
>   write(Arity).
> write_command(type(Loc,Type,_)) :-
>   write('add type, '),write(Type),write(', to '),write_loc(Loc).
> write_command(atom(Loc,Atom,_)) :-
>   write('add atom, '),write(Atom),write(', to '),write_loc(Loc).
> write_command(fun(Functor,Arity,_)) :-
>   write('evaluate functional description, '),write(Functor),write('/'),
>   write(Arity).
> 
> write_command(empty) :-
>   write('empty category').
> write_command(empty_close) :-
>   write('close empty categories under rules').
> write_command(apply_once(RuleName,_Empty,DtrNum)) :-
>   write('apply daughter '),write(DtrNum),write(' of rule '),
>   write(RuleName),write(' to empty category').
> 
> write_command(lex(Word,WordStart)) :-
>   write('derive: '),write(Word),
>   write(' from base entry: '),write(WordStart).
> write_command(fun_clause(Functor,Arity)) :-
>   write('evaluate functional clause for '),write(Functor),write('/'),
>   write(Arity).
> write_command(comp_clause(Rel,Arity)) :-
>   write('resolve relational clause for '),write(Rel),write('/'),write(Arity).
> 
> write_command(lr(RuleName,WordIn,_)) :-
>   write('apply lexical rule, '),write(RuleName),
>   write(', to '),write(WordIn).
> write_command(morph_input(WordIn,WordOut)) :-
>   var(WordOut) -> write('apply morph to input: '),write(WordIn)
> % write_command(morph_output(WordIn,WordOut)) :-
>   ; write('apply morph to input: '),write(WordIn),write(', output: '),
>     write(WordOut).
> write_command(lrwhen) :-
>   write('apply morph condition').
> write_command(lex_pivot_unify(Word,_,_,_)) :-
>   write('unify pivot template and '),write(Word).
> 
> write_command(neg) :-
>   write('resolve negated goal').
> write_command(shallow) :-
>   write('execute shallow cut').
> write_command(exteq) :-
>   write('check extensional identity').
> write_command(eq) :-
>   write('unify').
> write_command(prolog(PGoal)) :-
>   write('resolve prolog hook: '),write(PGoal).
> write_command(prolog2(PGoal)) :-
>   write('resolve quantified prolog hook: '),write(PGoal).
> write_command(when) :-
>   write('block conditional').
> write_command(comp(Functor,Arity)) :-
>   write('resolve goal, '),write(Functor),write('/'),write(Arity).
> 
> write_command(rule_close) :-
>   write('close chart edge under rule application').
> write_command(rule(RuleName)) :-
>   write('apply rule, '),write(RuleName).
> 
> write_command(forall_rules(_,_)) :-
>   write('close rule instance under forall/2 rules').
> write_command(forall_rule(FAName,_,_)) :-
>   write('close rule instance under forall/2 rule '),write(FAName).
> write_command(match_forall_rule_name(RName0,_,RName)) :-
>   write('match rule name argument '), write(RName0),
>   write(' with rule name '),write(RName).
> write_command(match_forall_rule(_,_,RName)) :-
>   write('match mother and daughters of '), write(RName).
> 
> write_command(forall_lexes(Word,_)) :-
>   write('close lexical item, '),write(Word),write(', under forall/2 rules').
> write_command(forall_lex(FAName,Word,_)) :-
>   write('close lexical item, '),write(Word),write(', under forall/2 rule '),write(FAName).
> write_command(match_forall_lex_name(Word0,_,Word)) :-
>   write('match word name argument '), write(Word0),
>   write(' with word '),write(Word).
> write_command(match_forall_lex(Word,_)) :-
>   write('match entry for '), write(Word).
> 
> write_command(sem_index(_,_,_)) :-
>   write('build semantic index from root').
> write_command(pivot_tmpl(_,_,_)) :-
>   write('build pivot template from index').
> write_command(pivot_find(_,_,_)) :-
>   write('find pivot').
> write_command(pivot_lex(WordStart,_,_)) :-
>   write('match pivot against entry derived from '),write(WordStart).
> write_command(pivot_empty(_,_)) :-
>   write('match pivot against empty category').
> write_command(pivot_ncrule(RuleName,_,_)) :-
>   write('match pivot against mother of non-chain rule, '),write(RuleName).
> write_command(chain_crule(RuleName,_,_,_,_,ChainSource)) :-
>   write('apply chain rule, '),write(RuleName),write(', to '),
>   write_source(ChainSource).
> write_command(chain_check(_,_,_,_,ChainSource)) :-
>   write('check for link from '),write_source(ChainSource),write(' to root').
> write_command(pivot_gen(_,_,_,_,_)) :-
>   write('recursively generate from pivot').
> write_command(pre_chain_gen(_,_,_,_,_,ChainSource,_)) :-
>   write('recursively generate pre-head daughters from '),
>   write_source(ChainSource).
> write_command(post_chain_gen(_,_,_,_,_,_,ChainSource,_)) :-
>   write('recursively generate post-head daughters from '),
>   write_source(ChainSource).
> write_command(pivot_conn(_,_,_,_,_,_,_,_,_)) :-
>   write('connect pivot to root').
> write_command(new_chain_conn(_,_,_,_,_,_,_,_,_,_)) :-
>   write('connect new chain node to root').
> write_command(root_chain_unify(_,_,_,_,ChainSource)) :-
>   write('unify '),write_source(ChainSource),write(' with root').
> 
> 
> write_loc(nonheaddtr(N,RuleSource)) :-
>   write('non-head daughter '),write(N),write(', '),
>   (RuleSource = ncrule(RuleName)
>   -> write('non-chain rule '),write(RuleName)
>    ; RuleSource = crule(RuleName),
>      write('chain rule '),write(RuleName)).
> write_loc(pivot) :-
>   write('pivot').
> write_loc(empty) :-
>   write('empty cat').
> write_loc(ineq) :-
>   write('inequated desc').
> write_loc(feat(F)) :-
>   write('value at '),write(F).
> write_loc(lex) :-
>   write('lex entry').
> write_loc(cons(T)) :-
>   write(T),write('-constrained FS').
> write_loc(lrin) :-
>   write('LR input').
> write_loc(lrout) :-
>   write('LR output').
> write_loc(left) :-
>   write('left arg').
> write_loc(right) :-
>   write('right arg').
> write_loc(arg(N)) :-
>   write('arg '),write(N).
> write_loc(query_desc) :-
>   write('query desc').
> write_loc(edge) :-
>   write('edge').
> write_loc(dtrlist) :-
>   write('dtr list').
> write_loc(mother) :-
>   write('mother').
> write_loc(sem_head) :-
>   write('semantic head').
> 
> display_current(apply_once(_,empty(N,-1,FS,Dtrs,RuleName),
>                            _)) :-
>   !,length(Dtrs,ND),
>   (print_empty(N,FS,Dtrs,RuleName,ND)
>   ; true).
> display_current(forall_rules(RuleName,FS)) :-
>   !,write('CREATED BY: '),write(RuleName),nl,
>   pp_fs(FS),nl.
> display_current(forall_rule(_,FS,RuleName)) :-
>   !,write('CREATED BY: '),write(RuleName),nl,
>   pp_fs(FS),nl.
> display_current(match_forall_rule_name(_,FS,RuleName)) :-
>   !,write('CREATED BY: '),write(RuleName),nl,
>   pp_fs(FS),nl.
> display_current(match_forall_rule(Dtrs,FS,RuleName)) :-
>   !,write('CREATED BY: '),write(RuleName),nl,
>   write('MOTHER: '),pp_fs(FS),nl,
>   write('DAUGHTERS: '),pp_fs(Dtrs),nl.
> display_current(forall_lexes(Word,FS)) :-
>   !,write('WORD: '),write(Word),nl,
>   pp_fs(FS),nl.
> display_current(forall_lex(_,Word,FS)) :-
>   !,write('WORD: '),write(Word),nl,
>   pp_fs(FS),nl.
> display_current(match_forall_lex_name(_,FS,Word)) :-
>   !,write('WORD: '),write(Word),nl,
>   pp_fs(FS),nl.
> display_current(match_forall_lex(Word,FS)) :-
>   !,write('WORD: '),write(Word),nl,
>   pp_fs(FS),nl.
> display_current(unify(_,VarName,FS,Var)) :-
>   !,(\+ \+ (empty_assoc(AssocIn),
>             duplicates_list([FS,Var],AssocIn,DupsMid,AssocIn,_,0,_),
>             write('CURRENT STRUCTURE:'),nl,
>             pp_fs(FS,DupsMid,DupsMid2,AssocIn,VisMid,0,AssocIn,HDMid),nl,
>             write('VARIABLE, '),write(VarName),write(':'),nl,
>             pp_fs(Var,DupsMid2,_,VisMid,_,0,HDMid,_),nl)).
> display_current(patheq(_,_,_,FS)) :-
>   !,pp_fs(FS),nl.
> display_current(ineq_add(_,FS)) :-
>   !,pp_fs(FS),nl.
> display_current(featval(_,_,FS)) :-
>   !,pp_fs(FS),nl.
> display_current(macro(_,FS)) :-
>   !,pp_fs(FS),nl.
> display_current(type(_,_,FS)) :-
>   !,pp_fs(FS),nl.
> display_current(atom(_,_,FS)) :-
>   !,pp_fs(FS),nl.
> display_current(fun(_,_,FS)) :-
>   !,pp_fs(FS),nl.
> display_current(lr(_,_,FS)) :-
>   !,pp_fs(FS),nl.
> display_current(lex_pivot_unify(Word,LexFS,PivotFS,RootSource)) :-
>   !,write('ROOT: '),write_source(RootSource),nl,
>     (\+ \+ (empty_assoc(AssocIn),
> 	    duplicates_list([LexFS,PivotFS],AssocIn,DupsMid,AssocIn,_,0,_),
>             write('STRUCTURE FOR '),write(Word),write(':'),nl,
>             pp_fs(LexFS,DupsMid,DupsMid2,AssocIn,VisMid,0,AssocIn,HDMid),nl,
>             write('PIVOT:'),nl,
>             pp_fs(PivotFS,DupsMid2,_,VisMid,_,0,HDMid,_),nl)).
> display_current(sem_index(QFS,IndexFS,RootSource)) :-
>   !,(\+ \+ (empty_assoc(AssocIn),
> 	    duplicates_list([QFS,IndexFS],AssocIn,DupsMid,AssocIn,_,0,_),
>             write('ROOT: '),write_source(RootSource),nl,
>             pp_fs(QFS,DupsMid,DupsMid2,AssocIn,VisMid,0,AssocIn,HDMid),nl,
>             write('INDEX:'),nl,
>             pp_fs(IndexFS,DupsMid2,_,VisMid,_,0,HDMid,_),nl)).
> display_current(pivot_tmpl(IndexFS,PivotFS,RootSource)) :-
>   !,(\+ \+ (empty_assoc(AssocIn),
> 	    duplicates_list([IndexFS,PivotFS],AssocIn,DupsMid,AssocIn,_,0,_),
>             write('ROOT: '),write_source(RootSource),nl,
>             write('INDEX:'),nl,
>             pp_fs(IndexFS,DupsMid,DupsMid2,AssocIn,VisMid,0,AssocIn,HDMid),nl,
>             write('PIVOT TEMPLATE:'),nl,
>             pp_fs(PivotFS,DupsMid2,_,VisMid,_,0,HDMid,_),nl)).
> display_current(pivot_find(PivotFS,PivotSource,RootSource)) :-
>   !,write('ROOT: '),write_source(RootSource),nl,
>   write('PIVOT'),
>   (nonvar(PivotSource)
>   -> write(': '),
>      write_source(PivotSource)
>    ; write(' TEMPLATE:')),
>   nl,
>   pp_fs(PivotFS),nl.
> display_current(pivot_lex(_,PivotFS,RootSource)) :-
>   !,write('ROOT: '),write_source(RootSource),nl,
>   write('PIVOT:'),nl,
>   pp_fs(PivotFS),nl.
> display_current(pivot_empty(PivotFS,RootSource)) :-
>   !,write('ROOT: '),write_source(RootSource),nl,
>   write('PIVOT:'),nl,
>   pp_fs(PivotFS),nl.
> display_current(pivot_ncrule(_,PivotFS,RootSource)) :-
>   !,write('ROOT: '),write_source(RootSource),nl,
>   write('PIVOT:'),nl,
>   pp_fs(PivotFS),nl.
> display_current(chain_crule(_,RootFS,ChainFS,PivotSource,RootSource,
>                             ChainSource)) :-
>   !,(\+ \+ (empty_assoc(AssocIn),
> 	    duplicates_list([RootFS,ChainFS],AssocIn,DupsMid,AssocIn,_,0,_),
>             write('ROOT: '),write_source(RootSource),nl,
>             pp_fs(RootFS,DupsMid,DupsMid2,AssocIn,VisMid,0,AssocIn,HDMid),nl,
>             write('CHAIN NODE: '),write_source(ChainSource),nl,
>             pp_fs(ChainFS,DupsMid2,_,VisMid,_,0,HDMid,_),nl,
> 	    write('PIVOT: '),write_source(PivotSource),nl)).
> display_current(chain_check(RootFS,ChainFS,PivotSource,RootSource,ChainSource)) :-
>   !,(\+ \+ (empty_assoc(AssocIn),
> 	    duplicates_list([RootFS,ChainFS],AssocIn,DupsMid,AssocIn,_,0,_),
>             write('ROOT: '),write_source(RootSource),nl,
>             pp_fs(RootFS,DupsMid,DupsMid2,AssocIn,VisMid,0,AssocIn,HDMid),nl,
>             write('CHAIN NODE: '),write_source(ChainSource),nl,
>             pp_fs(ChainFS,DupsMid2,_,VisMid,_,0,HDMid,_),nl)),
>   write('PIVOT: '),write_source(PivotSource),nl.
> display_current(pivot_gen(NewWords,RestNewWords,PivotSource,RootSource,PortFlag)) :-
>   !,write('ROOT: '),write_source(RootSource),nl,
>   write('PIVOT: '),write_source(PivotSource),nl,
>   (var(PortFlag) -> true
>   ; write('WORDS: '),nl,
>     number_display_head(NewWords,RestNewWords,RestNewWords,'P',nodots,0),nl
>   ).
> display_current(pre_chain_gen(NewWords,HeadWords,RestHeadWords,
>                               PivotSource,RootSource,ChainSource,PortFlag)) :-
>   !,write('ROOT: '),write_source(RootSource),nl,
>   write('CHAIN NODE: '),write_source(ChainSource),nl,
>   write('PIVOT: '),write_source(PivotSource),nl,
>   write('WORDS:'),nl,
>   (var(PortFlag)
>   -> write('... '),
>      number_display_head(HeadWords,RestHeadWords,RestHeadWords,'C',dots,0)
>    ; number_display_pre(NewWords,HeadWords,RestHeadWords,RestHeadWords,'C',
>                         dots,0)
>   ),
>   nl.
> display_current(post_chain_gen(NewWords,HeadWords,RestHeadWords,RestNewWords,
>                                PivotSource,RootSource,ChainSource,PortFlag)) :-
>   !,write('ROOT: '),write_source(RootSource),nl,
>   write('CHAIN NODE: '),write_source(ChainSource),nl,
>   write('PIVOT: '),write_source(PivotSource),nl,
>   write('WORDS:'),nl,
>   (var(PortFlag)
>   -> number_display_pre(NewWords,HeadWords,RestHeadWords,RestHeadWords,'C',
>                         dots,0)
>    ; number_display_pre(NewWords,HeadWords,RestHeadWords,RestNewWords,'C',
>                         nodots,0)
>   ),
>   nl.
> display_current(pivot_conn(RootFS,PivotFS,Words,RestWords,HeadWords,
>                            RestHeadWords,PivotSource,RootSource,PortFlag)) :-
>   !,write('WORDS:'),nl,
>   (var(PortFlag)
>   -> write('... '),
>      number_display_head(HeadWords,RestHeadWords,RestHeadWords,'P',dots,0)
>    ; number_display_pre(Words,HeadWords,RestHeadWords,RestWords,'P',nodots,0)
>   ),
>   nl,
>   (\+ \+ (empty_assoc(AssocIn),
> 	  duplicates_list([RootFS,PivotFS],AssocIn,DupsMid,AssocIn,_,0,_),
>           write('ROOT: '),write_source(RootSource),nl,
>           pp_fs(RootFS,DupsMid,DupsMid2,AssocIn,VisMid,0,AssocIn,HDMid),nl,
>           write('PIVOT: '),write_source(PivotSource),nl,
>           pp_fs(PivotFS,DupsMid2,_,VisMid,_,0,HDMid,_),nl)).
> display_current(new_chain_conn(RootFS,ChainFS,Words,HeadWords,
>                                RestHeadWords,RestWords,PivotSource,RootSource,
>                                ChainSource,PortFlag)) :-
>   !,
>   write('WORDS:'),nl,
>   (var(PortFlag)
>   -> write('... '),
>      number_display_head(HeadWords,RestHeadWords,RestHeadWords,'C',dots,0)
>    ; number_display_pre(Words,HeadWords,RestHeadWords,RestWords,'C',nodots,0)
>   ),
>   nl,
>   (\+ \+ (empty_assoc(AssocIn),
> 	  duplicates_list([RootFS,ChainFS],AssocIn,DupsMid,AssocIn,_,0,_),
>           write('ROOT: '),write_source(RootSource),nl,
>           pp_fs(RootFS,DupsMid,DupsMid2,AssocIn,VisMid,0,AssocIn,HDMid),nl,
>           write('CHAIN NODE: '),write_source(ChainSource),nl,
>           pp_fs(ChainFS,DupsMid2,_,VisMid,_,0,HDMid,_),nl,
>           write('PIVOT: '),write_source(PivotSource),nl)).
> display_current(root_chain_unify(RootFS,ChainFS,PivotSource,RootSource,ChainSource)) :-
>   !,(\+ \+ (empty_assoc(AssocIn),
> 	    duplicates_list([RootFS,ChainFS],AssocIn,DupsMid,AssocIn,_,0,_),
>             write('ROOT: '),write_source(RootSource),nl,
>             pp_fs(RootFS,DupsMid,DupsMid2,AssocIn,VisMid,0,AssocIn,HDMid),nl,
>             write('CHAIN NODE: '),write_source(ChainSource),nl,
>             pp_fs(ChainFS,DupsMid2,_,VisMid,_,0,HDMid,_),nl,
>             write('PIVOT: '),write_source(PivotSource),nl)).
> display_current(_) :-
>   write(user_error,'Not valid at this port'),nl(user_error),
>   flush_output(user_error).
> 
> write_source(base(Word)) :-
>   write(Word).
> write_source(deriv(Word,WordStart)) :-
>   write(Word),write(' (derived from '),write(WordStart),write(')').
> write_source(empty) :-
>   write('empty category').
> write_source(ncrule(RuleName)) :-
>   write('mother of non-chain rule '),write(RuleName).
> write_source(crule(RuleName)) :-
>   write('mother of chain rule '),write(RuleName).
> write_source(nonheaddtr(N,RuleSource)) :-
>   write('non-head daughter '),write(N),write(', '),
>   (RuleSource = ncrule(RuleName)
>   -> write('non-chain rule '),write(RuleName)
>    ; RuleSource = crule(RuleName),
>      write('chain rule '),write(RuleName)).
> write_source(pivot) :-
>   write('pivot').
> write_source(query) :-
>   write('query').
> 
> number_display_pre(Words,HeadWords,RestHeadWords,RestWords,Delimiter,Dots,N) :-
>   Words == HeadWords,
>   !,number_display_head(HeadWords,RestHeadWords,RestWords,Delimiter,Dots,N).
> number_display_pre([W|Ws],HeadWords,RestHeadWords,RestWords,Delimiter,Dots,
>                    N) :-
>   write(N),write(' '),write(W),write(' '),
>   SN is N + 1,
>   number_display_pre(Ws,HeadWords,RestHeadWords,RestWords,Delimiter,Dots,SN).
> 
> number_display_head(HeadWords,RestHeadWords,RestWords,Delimiter,Dots,N) :-
>   HeadWords == RestHeadWords,  % empty head
>   !,write(Delimiter),write(' '),
>   number_display_post(RestHeadWords,RestWords,Dots,N).
> number_display_head([W|Ws],RestHeadWords,RestWords,Delimiter,Dots,N) :-
>   write(Delimiter),write(' '),write(W),write(' '),
>   SN is N + 1,
>   number_display_head_rest(Ws,RestHeadWords,RestWords,Delimiter,Dots,SN).
> 
> number_display_head_rest(HeadWords,RestHeadWords,RestWords,Delimiter,Dots,N) :-
>   HeadWords == RestHeadWords,
>   !,write(Delimiter),write(' '),
>   number_display_post(RestHeadWords,RestWords,Dots,N).
> number_display_head_rest([W|Ws],RestHeadWords,RestWords,Delimiter,Dots,N) :-
>   write(N),write(' '),write(W),write(' '),
>   SN is N + 1,
>   number_display_head_rest(Ws,RestHeadWords,RestWords,Delimiter,Dots,SN).
> 
> number_display_post(PostWords,RestWords,Dots,_) :-
>   PostWords == RestWords,
>   !,(Dots = dots
>     -> write('...')
>      ; true).
> number_display_post([W|Ws],RestWords,Dots,N) :-
>   SN is N + 1,
>   write(W),write(' '),write(SN),write(' '),
>   number_display_post(Ws,RestWords,Dots,SN).
> 
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Breakpoint glue code for emacs-lisp 
> 
> %ale_break_at(File,Line) :-
> %  ale_debugging(File),
> %  ale_breakable_lines(BLs),
> %  LineFrom0 is Line - 1,
> %  member(LineFrom0,BLs),
> %  !,assert(ale_break(LineFrom0)).
> %ale_break_at(_,_) :-
> %  format(user_error, '~n{Could not set breakpoint}~n', []),
> %  flush_output(user_error).
> 
> %ale_remove_lc(File,Line,Line1) :-
> %  ale_debugging(File),
> %  LineFrom0 is Line - 1,
> %  retract(ale_break(LineFrom0)),
> %  !,emacs_format(user_error,'10L{REMOVEBREAK ~w "~a"}10R',[Line,File]),
> %  flush_output(user_error),
> %  Line = Line1.
> %ale_remove_lc(_,Line0,Line) :-
> %  Line = Line0.   % a favour for emacs:emacs_remove_line_condition/2
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % ale_leash/1: check leashing on current command
> ale_leash(Command) :-
>   current_predicate(ale_no_leash,ale_no_leash(_)),
>   ale_no_leash(Command),
>   !,fail.
> ale_leash(_).
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Labelling predicates - intercept token stream directly and record line
> %  numbers of source-code
> 
> label_items :-
>   alec_announce('Indexing source files...'),  
>   clause(ale_debug(File),true),
>   label_items(File),
>   fail.
> label_items.
> 
> label_items(AbsFile) :-
> %  absolute_file_name(File,AbsFile),
>   open(AbsFile,read,GramS),
>   label_preds(GramS,AbsFile).		% BLs),
> %  close(GramS).
> %  sort(BLs,BreakableLines),
> %  assert(ale_debugging(AbsFile)),
> %  assert(ale_breakable_lines(BreakableLines)).  
> 
> label_preds(GramS,AbsFile) :-
>   read_term(GramS,Term,[layout(Layout),variable_names(Va)]),
>   ( (current_predicate(term_expansion,term_expansion(_,_,_,_)),
>      term_expansion(Term,Layout,ExpTerm,ExpLayout)) -> true
>   ; expand_term(Term,ExpTerm),
>     ExpLayout = Layout
>   ),
>   ( ExpLayout == [] -> SrcLayout = _ ; SrcLayout = ExpLayout),  % variable will be expanded as appropriate by label_term/4
>   ( ExpTerm == end_of_file -> close(GramS)
>   ; label_term(ExpTerm,SrcLayout,Va,AbsFile) -> label_preds(GramS,AbsFile)
>   ; label_preds(GramS,AbsFile)   % throw everything else out --- we consult it anyway.
>   ).
> 
> :- multifile label_term/4.
> % label_term(end_of_file,GramS,_,_,_) :-
> %  !,close(GramS).
> label_term('--->'(Word,DescorGoal),[_,WordLayout,DescorGoalLayout],Va,AbsFile) :-
>   !,( var(WordLayout) -> WordLabel = []
>     ; is_list(WordLayout) -> WordLayout = [WordLine|_], WordLabel = [AbsFile|WordLine]
>     ; WordLine = WordLayout, WordLabel = [AbsFile|WordLine]
>     ),
>     ( var(DescorGoal) -> Desc = DescorGoal, Goal = true, DescLayout = DescorGoalLayout,
> 	                LabelledGoal = ltrue
>     ; functor(DescorGoal,goal,2) -> arg(1,DescorGoal,Desc), arg(2,DescorGoal,Goal),
>     	                            DescorGoalLayout = [_,DescLayout,GoalLayout],
>     	                            label_body(Goal,GoalLayout,LabelledGoal,Va,AbsFile)
>     ; Desc = DescorGoal, Goal = true, LabelledGoal = ltrue, DescLayout = DescorGoalLayout
>     ),
>   label_desc(Desc,DescLayout,LabelledDesc,_,Va,AbsFile),
>   assertz('l--->'(Word,WordLabel,LabelledDesc,LabelledGoal)).
> label_term(if(Head,Body),[_,HeadLayout,BodyLayout],Va,AbsFile) :-
>   !,label_compound(Head,HeadLayout,LabelledHead,_,Va,AbsFile),
>   label_body(Body,BodyLayout,LabelledBody,Va,AbsFile),
>   assertz(lif(LabelledHead,LabelledBody)).
> label_term('+++>'(FHead,FResult),[_,HeadLayout,ResLayout],Va,AbsFile) :-
>   !,label_compound(FHead,HeadLayout,LabelledHead,_,Va,AbsFile),
>   label_desc(FResult,ResLayout,LabelledResult,_,Va,AbsFile),
>   assertz('l+++>'(LabelledHead,LabelledResult)).
> label_term(forall(Name,do('--->'(Word,Entry),DoBody)),
> 	   [ForallLine,_,[_,[LexLine,_,_EntryLayout],DoBodyLayout]],Va,AbsFile) :-
>   !, ( var(ForallLine) -> ForallLabel = [] ; ForallLabel = [AbsFile|ForallLine] ),
>   ( var(LexLine) -> LexLabel = [] ; LexLabel = [AbsFile|LexLine] ),
> %  label_desc(Entry,EntryLayout,LabelledEntry,_,Va,AbsFile), --- treated as conditional
>   label_body(DoBody,DoBodyLayout,LabelledDoBody,Va,AbsFile),
>   assertz(lforall_lex(Name,ForallLabel,ldo_lex(Word,LexLabel,Entry,LabelledDoBody))).
> label_term(forall(Name,do(rule(RuleName,'===>'(Mother,RuleRHS)),DoBody)),
> 	   [ForallLine,_,[_,[RuleLine,_,[ArrowLine,_MotherLayout,_RHSLayout]],DoBodyLayout]],Va,AbsFile) :-
>   !, ( var(ForallLine) -> ForallLabel = [] ; ForallLabel = [AbsFile|ForallLine] ),
>   ( var(RuleLine) -> RuleLabel = [] ; RuleLabel = [AbsFile|RuleLine] ),
>   ( var(ArrowLine) -> ArrowLabel = [] ; ArrowLabel = [AbsFile|ArrowLine] ),
> %  label_desc(Mother,MotherLayout,LabelledMother,_,Va,AbsFile), --- these are treated as conditionals
> %  label_desc(RuleRHS,RHSLayout,LabelledRuleRHS,_,Va,AbsFile),
>   label_body(DoBody,DoBodyLayout,LabelledDoBody,Va,AbsFile),
>   assertz(lforall_rule(Name,ForallLabel,
> 		       ldo_rule(RuleName,RuleLabel,Mother,ArrowLabel,RuleRHS,LabelledDoBody))).
> label_term(lex_rule(RuleName,LRBody),[_,_,BodyLayout],Va,AbsFile) :-
>   !,label_lr_body(LRBody,BodyLayout,LabelledLRBody,InLine,Va,AbsFile),
>   ( InLine == [] -> InLabel = []
>   ; InLabel = [AbsFile|InLine]
>   ),
>   assertz(llr(RuleName,InLabel,LabelledLRBody)).
> label_term(rule(RuleName,'===>'(Mother,RuleBody)),
> 	   [RuleLine,_,[_,MotherLayout,BodyLayout]],Va,AbsFile) :-
>   !,( var(RuleLine) -> RuleLabel = []
>     ; RuleLabel = [AbsFile|RuleLine]
>     ),
>   label_desc(Mother,MotherLayout,LabelledMother,_,Va,AbsFile),
>   label_rule_body(RuleBody,BodyLayout,LabelledRuleBody,Va,AbsFile),
>   assertz(lrule(RuleName,RuleLabel,LabelledMother,LabelledRuleBody)).
> label_term(macro(MacroHead,MacroDesc),[_,_,DescLayout],Va,AbsFile):-
>   !,label_desc(MacroDesc,DescLayout,LabelledDesc,FirstLine,Va,AbsFile),
>   capture_macro_vars(LabelledDesc,MacroHead,LabelledMacroDesc),
>   assertz(lmacro(MacroHead,FirstLine,LabelledMacroDesc)).
> label_term((empty Desc),[OpLine,DescLayout],Va,AbsFile) :-
>   !,( var(OpLine) -> OpLabel = []
>     ; OpLabel = [AbsFile|OpLine]
>     ),
>   label_desc(Desc,DescLayout,LabelledDesc,_,Va,AbsFile),
>   assertz(lemptyentry(OpLabel,LabelledDesc)).
> label_term(semantics(Pred),[OpLine,_],_,AbsFile) :-
>   !,( var(OpLine) -> OpLabel = []
>     ; OpLabel = [AbsFile|OpLine]
>     ),
>   assertz(lsemantics(OpLabel,Pred)).
> label_term(sub(_,_),_,_,_) :-  % skip these for now
>   !.
> label_term(ext(_),_,_,_) :-
>   !.
> label_term(cons(T,RHS),[_,_,RHSLayout],Va,AbsFile) :-
>   !,
>   ( nonvar(RHS), RHS = (Cons goal Goal) -> RHSLayout = [_,ConsLayout,GoalLayout],
>                                          label_desc(Cons,ConsLayout,LabelledCons,FirstLine,Va,AbsFile),
>                                          label_body(Goal,GoalLayout,LabelledGoal,Va,AbsFile)
>   ; label_desc(RHS,RHSLayout,LabelledCons,FirstLine,Va,AbsFile),
>     LabelledGoal = ltrue
>   ),
>   ConsLabel = [AbsFile|FirstLine],
>   assertz(lcons(T,ConsLabel,LabelledCons,_,d_query(LabelledGoal))).
> 
> label_rule_body((Op1,Op2),[_,Op1Layout,Op2Layout],(LabelledOp1,LabelledOp2),
> 		Va,AbsFile) :-
>   !,label_rule_body(Op1,Op1Layout,LabelledOp1,Va,AbsFile),
>   label_rule_body(Op2,Op2Layout,LabelledOp2,Va,AbsFile).
> label_rule_body(cat> DtrDesc,[_,_,DescLayout],lcat(LabelledDtrDesc),Va,
> 		AbsFile) :-
>   !,label_desc(DtrDesc,DescLayout,LabelledDtrDesc,_,Va,AbsFile).
> label_rule_body(sem_head> DtrDesc,[_,_,DescLayout],lsem_head(LabelledDtrDesc),
> 		Va,AbsFile) :-
>   !,label_desc(DtrDesc,DescLayout,LabelledDtrDesc,_,Va,AbsFile).
> label_rule_body(cats> DtrDesc,[_,_,DescLayout],lcats(LabelledDtrDesc),Va,
> 		AbsFile) :-
>   !,label_desc(DtrDesc,DescLayout,LabelledDtrDesc,_,Va,AbsFile).
> label_rule_body(goal> GoalBody,[_,_,GoalLayout],lgoal(LabelledGoalBody),Va,
> 		AbsFile) :-
>   !,label_body(GoalBody,GoalLayout,LabelledGoalBody,Va,AbsFile).
> label_rule_body(sem_goal> GoalBody,[_,_,GoalLayout],
> 		lsem_goal(LabelledGoalBody),Va,AbsFile):-
>   !,label_body(GoalBody,GoalLayout,LabelledGoalBody,Va,AbsFile).
> 
> label_lr_body(morphs(NMBody,Morphs),[_,BodyLayout,MorphsLayout],
>               llrbody(LabelledNMBody,LabelledMorphs),InLine,Va,AbsFile) :-
>   label_lr_body_proper(NMBody,BodyLayout,LabelledNMBody,InLine,Va,AbsFile),
>   label_morphs(Morphs,MorphsLayout,LabelledMorphs,AbsFile).
> 
> label_lr_body_proper(if(NCBody,Cond),[_,BodyLayout,CondLayout],
>                      lif(LabelledNCBody,LabelledCond),InLine,Va,AbsFile) :-
>   !,label_lr_body_no_cond(NCBody,BodyLayout,LabelledNCBody,InLine,Va,AbsFile),
>   label_body(Cond,CondLayout,LabelledCond,Va,AbsFile).
> label_lr_body_proper(NCBody,Layout,LabelledNCBody,InLine,Va,AbsFile):-
>   label_lr_body_no_cond(NCBody,Layout,LabelledNCBody,InLine,Va,AbsFile).
> 
> label_lr_body_no_cond('**>'(DescorGoalIn,DescorGoalOut),[_,InLayout,OutLayout],
>                       llrmap(LabelledDescIn,LabelledGoalInTemplate,LabelledDescOut,
> 			     LabelledGoalOutTemplate),
> 		      InLine,Va,AbsFile) :-
>   ( var(DescorGoalIn) -> LabelledGoalInTemplate = _, MacroVars = [], DescIn = DescorGoalIn,
>                          DescInLayout = InLayout
>   ; functor(DescorGoalIn,goal,2) -> arg(1,DescorGoalIn,DescIn), arg(2,DescorGoalOut,GoalIn),
>                                     InLayout = [_,DescInLayout,GoalInLayout],
>                                     label_body(GoalIn,GoalInLayout,LabelledGoalIn,Va,AbsFile),
>                                     term_variables(GoalIn,MacroVars),
>                                     cmv_body(LabelledGoalIn,MacroVars,LabelledGoalInTemplate)
>   ; LabelledGoalInTemplate = _, MacroVars = [], DescIn = DescorGoalIn, DescInLayout = InLayout
>   ),
>   ( var(DescorGoalOut) -> LabelledGoalOutTemplate = ltrue, DescOutLayout = OutLayout
>   ; functor(DescorGoalOut,goal,2) -> arg(1,DescorGoalOut,DescOut), arg(2,DescorGoalOut,GoalOut),
>                                      OutLayout = [_,DescOutLayout,GoalOutLayout],
>                                      label_body(GoalOut,GoalOutLayout,LabelledGoalOut,Va,AbsFile),
>                                      cmv_body(LabelledGoalOut,MacroVars,LabelledGoalOutTemplate)
>   ; LabelledGoalOutTemplate = ltrue, DescOutLayout = OutLayout
>   ),	
>   label_desc(DescIn,DescInLayout,LabelledDescIn,InLine,Va,AbsFile),
>   label_desc(DescOut,DescOutLayout,LabelledDescOut,_,Va,AbsFile).
> 
> label_morphs((Morph,Morphs),[_,MLayout,MsLayout],
> 	     lmorph_seq(LabelledMorph,LabelledMorphs),AbsFile) :-
>   !,label_morph(Morph,MLayout,LabelledMorph,AbsFile),
>   label_morphs(Morphs,MsLayout,LabelledMorphs,AbsFile).
> label_morphs(Morph,Layout,LabelledMorph,AbsFile) :-
>   label_morph(Morph,Layout,LabelledMorph,AbsFile).
> 
> label_morph(when(NCMorph,Cond),[WhenLine,MorphLayout,_],
>             lmorph_cond(WhenLabel,LabelledNCMorph,Cond),AbsFile) :-
>   !,
>   ( var(WhenLine) -> WhenLabel = []
>   ; WhenLabel = [AbsFile|WhenLine]
>   ),
>   label_morph_no_cond(NCMorph,MorphLayout,LabelledNCMorph,AbsFile).
> 			% flush Cond (comma=1000)
> label_morph(NCMorph,Layout,LabelledNCMorph,AbsFile) :-
>   label_morph_no_cond(NCMorph,Layout,LabelledNCMorph,AbsFile).
> 
> label_morph_no_cond(becomes(StrIn,StrOut),[OpLine,_,_],
> 		    lmorph(OpLabel,StrIn,StrOut),AbsFile) :-
>     var(OpLine) -> OpLabel = []
>   ; OpLabel = [AbsFile|OpLine].
>                                            % flush StrIn and StrOut (when=950)
> 
> label_query((Body1,Body2),(LabelledBody1,LabelledBody2)) :-
>   !,label_query(Body1,LabelledBody1),
>   label_query(Body2,LabelledBody2).
> label_query((IfGoal -> ThenGoal ; ElseGoal),
> 	   lshallow([],LabelledIfGoal,LabelledThenGoal,
>                     LabelledElseGoal)) :-
>   !,label_query(IfGoal,LabelledIfGoal),
>   label_query(ThenGoal,LabelledThenGoal),
>   label_query(ElseGoal,LabelledElseGoal).
> label_query((Body1;Body2),(LabelledBody1;LabelledBody2)) :-
>   !,label_query(Body1,LabelledBody1),
>   label_query(Body2,LabelledBody2).
> label_query(\+ Goal,lneg([],LabelledGoal)):-
>   !,label_query(Goal,LabelledGoal).
> label_query((Desc1 =@ Desc2),lexteq([],LabelledD1,LabelledD2)) :-
>   !,label_query_arg(Desc1,LabelledD1),  % HACK: these used to have a third anon arg - why?
>   label_query_arg(Desc2,LabelledD2).
> label_query((Desc1 = Desc2),lunify([],LabelledD1,LabelledD2)) :-
>   !,label_query_arg(Desc1,LabelledD1),  % HACK: these used to have a third anon arg - why?
>   label_query_arg(Desc2,LabelledD2).
> label_query(prolog(PGoal),lprolog([],PGoal)) :-
>   !.  % flush PGoal
> label_query(prolog(NVs,PGoal),lprolog([],NVs,PGoal)) :-
>   !.  % flush PGoal and NVs
> label_query(when(Cond,Body),lwhen([],Cond,LabelledBody)) :-
>   !,% label_cond(Cond,CondLayout,LabelledCond,_,Va,BLs,BLsMid),
>   label_query(Body,LabelledBody).
> label_query(!,lcut) :-
>   !.
> label_query((IfGoal -> ThenGoal),lshallow([],LabelledIfGoal,LabelledThenGoal,lfail)) :-
>   !,label_query(IfGoal,LabelledIfGoal),
>   label_query(ThenGoal,LabelledThenGoal).
> label_query(true,ltrue) :-
>   !.
> label_query(fail,lfail) :-
>   !.
> label_query(AtGoal,LabelledAtGoal) :-
>   label_query_compound(AtGoal,LabelledAtGoal).
> 
> label_query_compound(CompoundTerm,lcomp(Functor,Arity,[],LabelledDescList)) :-
>   CompoundTerm =.. [Functor|DescList],
>   functor(CompoundTerm,_,Arity),
>   label_query_arg_list(DescList,LabelledDescList).
> 
> label_query_arg_list([],[]).
> label_query_arg_list([ArgDesc|ArgDescs],[LD|LDs]) :-
>   label_query_arg(ArgDesc,LD),
>   label_query_arg_list(ArgDescs,LDs).
> 
> label_query_arg(X,lvar(X,'query variable',[])) :-
>   var(X),
>   !.
> label_query_arg(F:Desc,lfeat(F,[]):LabelledDesc) :-
>   !,label_query_arg(Desc,LabelledDesc).
> label_query_arg([],lelist([])) :-
>   !.
> label_query_arg([EltDesc|TailDesc],lnelist([],[],LabelledED,LabelledTD)) :-
>   !,label_query_arg(EltDesc,LabelledED),
>   label_query_tail(TailDesc,LabelledTD).
> label_query_arg((D1,D2),(LD1,LD2)) :-
>   !,label_query_arg(D1,LD1),
>   label_query_arg(D2,LD2).
> label_query_arg((D1;D2),(LD1;LD2)) :-
>   !,label_query_arg(D1,LD1),
>   label_query_arg(D2,LD2).
> label_query_arg((@ MacroCall),lmac(LabelledMC,[])) :-
>   !,label_query_comp(MacroCall,lcomp(Functor,_,_,LabelledDescs)),
>   LabelledMC =.. [Functor|LabelledDescs].
> label_query_arg((Path1 == Path2),lpatheq(Path1,Path2,[],LP1,LP2)) :-
>   !,label_query_path(Path1,LP1),
>   label_query_path(Path2,LP2).
> label_query_arg((=\= Desc),lineq([],LabelledDesc)) :-
>   !,label_query_arg(Desc,LabelledDesc).
> label_query_arg((a_ Atom),latom(Atom,[])) :-
>   !.
> label_query_arg(Type,ltype(Type,[])) :-
>   non_a_type(Type) -> !, true
>   ; error_msg((nl,write('undefined type '),write(Type),write(' used in query'),nl)).
> label_query_arg(Fun,lfun(LabelledFun)) :-
>   label_query_comp(Fun,LabelledFun).
> 
> label_query_tail(X,lvar(X,'query variable',[])) :-
>   var(X),
>   !.
> label_query_tail([],lelist([])) :-
>   !.
> label_query_tail([EltDesc|TailDesc],
>                  lnelist([],[],LabelledED,LabelledTD)) :-
>   !,label_query_arg(EltDesc,LabelledED),
>   label_query_tail(TailDesc,LabelledTD).
> label_query_tail(TailDesc,LabelledTailDesc) :-  % improper list
>   label_query_arg(TailDesc,LabelledTailDesc).
> 
> label_query_comp(CompoundTerm,lcomp(Functor,Arity,[],LabelledDList)) :-
>   CompoundTerm =.. [Functor|DescList],
>   functor(CompoundTerm,_,Arity),
>   label_query_arg_list(DescList,LabelledDList).
> 
> label_query_path([],[]).
> label_query_path([Feat|Path],[lfeat(Feat,[])|LPath]) :-
>   label_query_path(Path,LPath).
> 
> label_body((Body1,Body2),[_,Layout1,Layout2],(LabelledBody1,LabelledBody2),Va,
>            AbsFile) :-
>   !,label_body(Body1,Layout1,LabelledBody1,Va,AbsFile),
>   label_body(Body2,Layout2,LabelledBody2,Va,AbsFile).
> label_body((IfGoal -> ThenGoal ; ElseGoal),
> 	   [_,[ArrowLine,IfLayout,ThenLayout],ElseLayout],
>            lshallow(ArrowLabel,LabelledIfGoal,LabelledThenGoal,
>                     LabelledElseGoal),Va,AbsFile) :-
>   !,
>   ( var(ArrowLine) -> ArrowLabel = []
>   ; ArrowLabel = [AbsFile|ArrowLine]
>   ),
>   label_body(IfGoal,IfLayout,LabelledIfGoal,Va,AbsFile),
>   label_body(ThenGoal,ThenLayout,LabelledThenGoal,Va,AbsFile),
>   label_body(ElseGoal,ElseLayout,LabelledElseGoal,Va,AbsFile).
> label_body((Body1;Body2),[_,Layout1,Layout2],(LabelledBody1;LabelledBody2),Va,
>            AbsFile) :-
>   !,label_body(Body1,Layout1,LabelledBody1,Va,AbsFile),
>   label_body(Body2,Layout2,LabelledBody2,Va,AbsFile).
> label_body(\+ Goal,[NegLine,GoalLayout],lneg(NegLabel,LabelledGoal),
> 	   Va,AbsFile):-
>   !,
>   ( var(NegLine) -> NegLabel = []
>   ; NegLabel = [AbsFile|NegLine]
>   ),
>   label_body(Goal,GoalLayout,LabelledGoal,Va,AbsFile).
> label_body((Desc1 =@ Desc2),[OpLine,Layout1,Layout2],
> 	   lexteq(OpLabel,LabelledD1,LabelledD2),Va,AbsFile) :-
>   !,
>   ( var(OpLine) -> OpLabel = []
>   ; OpLabel = [AbsFile|OpLine]
>   ),
>   label_desc(Desc1,Layout1,LabelledD1,_,Va,AbsFile),
>   label_desc(Desc2,Layout2,LabelledD2,_,Va,AbsFile).
> label_body((Desc1 = Desc2),[OpLine,Layout1,Layout2],
> 	   lunify(OpLabel,LabelledD1,LabelledD2),Va,AbsFile) :-
>   !,
>   ( var(OpLine) -> OpLabel = []
>   ; OpLabel = [AbsFile|OpLine]
>   ),
>   label_desc(Desc1,Layout1,LabelledD1,_,Va,AbsFile),
>   label_desc(Desc2,Layout2,LabelledD2,_,Va,AbsFile).
> label_body(prolog(PGoal),[OpLine,_],lprolog(OpLabel,PGoal),_,
> 	   AbsFile) :-
>   !,  % flush PGoal
>   ( var(OpLine) -> OpLabel = []
>   ; OpLabel = [AbsFile|OpLine]
>   ).
> label_body(prolog(NVs,PGoal),[OpLine,_],lprolog(OpLabel,NVs,PGoal),_,
> 	   AbsFile) :-
>   !,  % flush PGoal
>   ( var(OpLine) -> OpLabel = []
>   ; OpLabel = [AbsFile|OpLine]
>   ).
> label_body(when(Cond,Body),[OpLine,_CondLayout,BodyLayout],
> 	   lwhen(OpLabel,Cond,LabelledBody),Va,AbsFile) :-
>   !,% label_cond(Cond,CondLayout,LabelledCond,_,Va,BLs,BLsMid),
>   ( var(OpLine) -> OpLabel = []
>   ; OpLabel = [AbsFile|OpLine]
>   ),
>   label_body(Body,BodyLayout,LabelledBody,Va,AbsFile).
> label_body(!,_,lcut,_,_) :- !.
> label_body((IfGoal -> ThenGoal),[ArrowLine,IfLayout,ThenLayout],
>            lshallow(ArrowLabel,LabelledIfGoal,LabelledThenGoal,lfail),
>            Va,AbsFile) :-
>   !,
>   ( var(ArrowLine) -> ArrowLabel = []
>   ; ArrowLabel = [AbsFile|ArrowLine]
>   ),
>   label_body(IfGoal,IfLayout,LabelledIfGoal,Va,AbsFile),
>   label_body(ThenGoal,ThenLayout,LabelledThenGoal,Va,AbsFile).
> label_body(true,_,ltrue,_,_) :- !.
> label_body(fail,_,lfail,_,_) :- !.
> label_body(AtGoal,Layout,LabelledAtGoal,Va,AbsFile) :-
>   label_compound(AtGoal,Layout,LabelledAtGoal,_,Va,AbsFile).
> 
> %label_cond(NV^Cond,[OpLine,NVLine,CondLayout],
> %	   lquant(NV,NVName,NVLine,LabelledCond),NVLine,Va,[NVLine,OpLine|BLs],
> %	   BLsRest) :-
> %  !,(var(NV) -> select_var(Va,NV,NVName),
> %                label_cond(Cond,CondLayout,LabelledCond,_,Va,BLs,BLsRest)
> %    ; error_msg((nl,write('non-variable used in existential quantifier: '),
> %		 write(NV^Cond),nl))
> %    ).
> %label_cond((C1,C2),[_,Layout1,Layout2],(LC1,LC2),FirstLine,Va,BLs,BLsRest) :-
> %  !,label_cond(C1,Layout1,LC1,FirstLine,Va,BLs,BLsMid),
> %  label_cond(C2,Layout2,LC2,_,Va,BLsMid,BLsRest).
> %label_cond((C1;C2),[_,Layout1,Layout2],(LC1;LC2),FirstLine,Va,BLs,BLsRest) :-
> %  !,label_cond(C1,Layout1,LC1,FirstLine,Va,BLs,BLsMid),
> %  label_cond(C2,Layout2,LC2,_,Va,BLsMid,BLsRest).
> %label_cond(FS=Desc,[OpLine,FSLine,DLayout],lcond(FS,FSName,FSLine,LD),FSLine,Va,
> %	   [FSLine,OpLine|BLs],BLsRest) :-
> %  var(FS) -> select_var(Va,FS,FSName),
> %             label_desc(Desc,DLayout,LD,_,Va,BLs,BLsRest)
> %  ; error_msg((nl,write('non-variable used on LHS of delay: '),write(FS=Desc),nl)).
> 
> label_desc(X,XLine,lvar(X,XName,XLabel),XLine,Va,AbsFile) :-
>   var(X),
>   !, (var(XLine) -> XLine = [], XLabel = [] ; XLabel = [AbsFile|XLine]),
>   select_var(Va,X,XName).
> label_desc((F:Desc),[_,FLayout,DLayout],
> 	   (lfeat(F,FLabel):LabelledDesc),FLine,Va,AbsFile) :-
>   !, ( var(FLayout) -> FLabel = [], FLine = []
>      ; is_list(FLayout) -> FLayout = [FLine|_], FLabel = [AbsFile|FLine]
>      ; FLine = FLayout, FLabel = [AbsFile|FLine]
>      ),
>   label_desc(Desc,DLayout,LabelledDesc,_,Va,AbsFile).
> label_desc([],ELine,lelist(ELabel),ELine,_,AbsFile):-
>   !,
>   ( var(ELine) -> ELine = [], ELabel = []
>   ; ELabel = [AbsFile|ELine]
>   ).
> label_desc([EltDesc|TailDesc],[LBrackLine,ELayout,TLayout],
>            lnelist(LBrackLabel,TailLabel,LabelledEltDesc,
> 		   LabelledTailDesc),
>            LBrackLine,Va,AbsFile) :-
>   !,
>   ( var(LBrackLine) -> LBrackLine = [], LBrackLabel = []
>   ; LBrackLabel = [AbsFile|LBrackLine]
>   ),
>   label_desc(TailDesc,TLayout,LabelledTailDesc,TailLine,Va,AbsFile),
>   ( TailLine == [] -> TailLabel = []
>   ; TailLabel = [AbsFile|TailLine]
>   ),
>   label_desc(EltDesc,ELayout,LabelledEltDesc,_,Va,AbsFile).
> label_desc((Desc1,Desc2),[_,Layout1,Layout2],(LD1,LD2),FirstLine,Va,AbsFile) :-
>   !, label_desc(Desc1,Layout1,LD1,FirstLine,Va,AbsFile),
>   label_desc(Desc2,Layout2,LD2,_,Va,AbsFile).
> label_desc((Desc1;Desc2),[_,Layout1,Layout2],(LD1;LD2),FirstLine,Va,AbsFile) :-
>   !,label_desc(Desc1,Layout1,LD1,FirstLine,Va,AbsFile),
>   label_desc(Desc2,Layout2,LD2,_,Va,AbsFile).
> label_desc((@ MacroCall),[OpLine,MLayout],lmac(LabelledMC,OpLabel),
> 	   OpLine,Va,AbsFile) :-
>   !,
>   ( var(OpLine) -> OpLabel = [], OpLine = []
>   ; OpLabel = [AbsFile|OpLine]
>   ),
>   label_compound(MacroCall,MLayout,lcomp(Functor,_,_,LabelledDescs),_,Va,
>                    AbsFile),
>   LabelledMC =.. [Functor|LabelledDescs].
> label_desc((Path1 == Path2),[OpLine,Layout1,Layout2],
> 	   lpatheq(Path1,Path2,OpLabel,LP1,LP2),
>            OpLine,_,AbsFile) :-
>   !,
>   ( var(OpLine) -> OpLabel = [], OpLine = []
>   ; OpLabel = [AbsFile|OpLine]
>   ),
>   label_path(Path1,Layout1,LP1,AbsFile),
>   label_path(Path2,Layout2,LP2,AbsFile).
> label_desc((=\= Desc),[OpLine,DLayout],lineq(OpLabel,LabelledDesc),
> 	   OpLine,Va,AbsFile) :-
>   !,
>   ( var(OpLine) -> OpLabel = [], OpLine = []
>   ; OpLabel = [AbsFile|OpLine]
>   ),
>   label_desc(Desc,DLayout,LabelledDesc,_,Va,AbsFile).
> label_desc((a_ Atom),[ALine,_],latom(Atom,ALabel),ALine,_,AbsFile) :-
>   !,  % flush Atom (comma=1000)
>   ( var(ALine) -> ALine = [], ALabel = []
>   ; ALabel = [AbsFile|ALine]
>   ).
> label_desc(Fun,FLayout,lfun(LabelledFun),FirstLine,Va,AbsFile):-
>   functor(Fun,Functor,FunArity),
>   clause(fun_spec(Functor,FunArity,_),true),
>   !,
>   label_compound(Fun,FLayout,LabelledFun,FirstLine,Va,AbsFile).
> label_desc(Type,TLine,ltype(Type,TLabel),TLine,_,AbsFile) :-
>   non_a_type(Type) ->  !,( var(TLine) -> TLine = [], TLabel = []
>                          ; TLabel = [AbsFile|TLine]
>                          )
>   ; error_msg((nl,write('undefined type '),write(Type),write(' used in description'),nl)).
> 
> label_path([],_,[],_).
> label_path([Feat|Path],[_,FLayout,PLayout],[lfeat(Feat,FLabel)|LPath],
>            AbsFile) :-
>   ( var(FLayout) -> FLabel = []
>   ; is_list(FLayout) -> FLayout = [FLine|_], FLabel = [AbsFile|FLine]
>   ; FLayout = FLine, FLabel = [AbsFile|FLine]
>   ),
>   label_path(Path,PLayout,LPath,AbsFile).
> 
> label_compound(CompoundTerm,CLayout,
>                lcomp(Functor,Arity,FunLabel,LabelledDescList),FunLine,
> 	       Va,AbsFile) :-
>   CompoundTerm =.. [Functor|DescList],
>   functor(CompoundTerm,_,Arity),
>   ( var(CLayout) -> FunLine = [], FunLabel = [],
>                     ( Arity =:= 0 -> LabelledDescList = []
> 		    ; label_desc_list(DescList,_,LabelledDescList,Va,AbsFile)
> 		    )
>   ; Arity =:= 0 -> CLayout = FunLine, FunLabel = [AbsFile|FunLine], LabelledDescList = []
>   ; CLayout = [FunLine|Layouts], FunLabel = [AbsFile|FunLine],
>     label_desc_list(DescList,Layouts,LabelledDescList,Va,AbsFile)
>   ).
> 
> % no longer need to consume left brack - can just call label_desc/7.
> %label_tail(X,XLine,lvar(X,XName,XLine),XLine,Va,[XLine|BLsRest],BLsRest):-
> %  var(X),
> %  !,select_var(Va,X,XName).
> %label_tail([],TokenS,lelist(RBrackLine),RBrackLine,TokenSRest,
> %           [RBrackLine|BLsRest],BLsRest):-
> %  !,trunc_select(rbrack(RBrackLine),TokenS,TokenSRest).
> %label_tail([EltDesc|TailDesc],TokenS,
> %           lnelist(HeadLine,TailLine,LabelledEltDesc,LabelledTailDesc),
> %           HeadLine,TokenSRest,BLs,BLsRest) :-
> %  !,trunc_select(',',TokenS,TokenSMid),
> %  label_desc(EltDesc,TokenSMid,LabelledEltDesc,HeadLine,TokenSMid2,BLs,BLsMid),
> %  label_tail(TailDesc,TokenSMid2,LabelledTailDesc,TailLine,TokenSRest,
> %             BLsMid,BLsRest).
> %label_tail(TailDesc,TokenS,LabelledTailDesc,HeadLine,TokenSRest,
> %           BLs,BLsRest) :-
> %  trunc_select('|',TokenS,TokenSMid),
> %  label_desc(TailDesc,TokenSMid,LabelledTailDesc,HeadLine,TokenSMid2,
> %             BLs,BLsRest),
> %  trunc_select(rbrack(_),TokenSMid2,TokenSRest).
> 
> label_desc_list([],[],[],_,_).
> label_desc_list([Desc|DescList],[DLayout|DLayouts],
> 		[LabelledDesc|LabelledDescList],Va,AbsFile) :-
>   label_desc(Desc,DLayout,LabelledDesc,_,Va,AbsFile),
>   label_desc_list(DescList,DLayouts,LabelledDescList,Va,AbsFile).
> 
> strip_labels(lvar(X,_,_),X).
> strip_labels(lfeat(F,_):LabelledDesc,F:Desc) :-
>   strip_labels(LabelledDesc,Desc).
> strip_labels(lelist(_),[]).
> strip_labels(lnelist(_,_,LabelledEltDesc,LabelledTailDesc),[EltDesc|TailDesc]) :-
>   strip_labels(LabelledEltDesc,EltDesc),
>   strip_labels(LabelledTailDesc,TailDesc).
> strip_labels((LD1,LD2),(Desc1,Desc2)) :-
>   strip_labels(LD1,Desc1),
>   strip_labels(LD2,Desc2).
> strip_labels((LD1;LD2),(Desc1;Desc2)) :-
>   strip_labels(LD1,Desc1),
>   strip_labels(LD2,Desc2).
> strip_labels(lmac(LabelledMC,_),(@ MacroCall)) :-
>   LabelledMC =.. [Macro|LabelledDescs],
>   strip_labels_list(LabelledDescs,Descs),
>   MacroCall =.. [Macro|Descs].
> strip_labels(lpatheq(Path1,Path2,_,_,_),(Path1 == Path2)).
> strip_labels(lineq(_,LabelledDesc),(=\= Desc)) :-
>   strip_labels(LabelledDesc,Desc).
> strip_labels(latom(Atom,_),(a_ Atom)).
> strip_labels(lfun(lcomp(Functor,_,_,LabelledDescs)),FunDesc) :-
>   strip_labels_list(LabelledDescs,Descs),
>   FunDesc =.. [Functor|Descs].
> strip_labels(ltype(Type,_),Type).
> 
> strip_labels_list([],[]).
> strip_labels_list([LD|LDs],[Desc|Descs]) :-
>   strip_labels(LD,Desc),
>   strip_labels_list(LDs,Descs).
>   
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % EFD-Closure
> 
> d_close_emptys_rules :-
>   reset_d_mode,
>   reset_d_skip_level,
>   retractall(emptynum(_)),
>   assert(emptynum(-1)),
>   d_meta_interp(empty_close,[],d_close_emptys_rules_act(MinimalClosedEmptys,ClosedRules)),
>   (MinimalClosedEmptys == []
>   -> assert((empty_cat(_,_,_,_,_) :- fail))
>    ; true),
>   ( member(empty(N,Node,FSOut,Dtrs,RuleName),
>            MinimalClosedEmptys),
>     assert(empty_cat(N,Node,FSOut,Dtrs,RuleName)),
>     fail
>   ; member(alec_rule(LabelledDtrs,Left,LabelledMother,RuleName,PrevDtrs,PrevDtrsRest,
> 		     DtrStore,DtrStoreRest,RuleLine,_),
>            ClosedRules),
>     assert(lclosedrule(RuleName,RuleLine,LabelledMother,LabelledDtrs,
>                        Left,PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest)),
>     fail
>   ; true
>   ).
>   d_close_emptys_rules_act(MinimalClosedEmptys,ClosedRules) :-
>     format('Collecting empty categories...~n',[]), 
>     ttyflush,
>     findall(empty(M,_,FS,[],empty),
>             (current_predicate(lemptyentry,lemptyentry(_,_)),
>              lemptyentry(EmptyLine,LabelledDesc),
>              d_meta_interp(empty,EmptyLine,d_add_to(LabelledDesc,FS,empty)),
>              gen_emptynum(M)),
>             BasicEmptys),
> %	format('Finished collecting empty cats~n',[]), % DEBUG
>     (ale_flag(subtest,off) -> MinimalEmptys = BasicEmptys
>     ; d_minimise_emptys(BasicEmptys,[],MinimalEmptys)
>     ),
>     d_close_emptys(MinimalEmptys,ClosedEmptys,ClosedRules),
> %	format('Finished d_close_emptys/3',[]), % DEBUG
>     (ale_flag(subtest,off) -> MinimalClosedEmptys = ClosedEmptys
>     ; d_minimise_emptys(ClosedEmptys,[],MinimalClosedEmptys)
>     ).
> 
> d_minimise_emptys([],MinimalEmptys,MinimalEmptys).
> d_minimise_emptys([BE|BasicEmptys],Accum,MinimalEmptys) :-
>   d_minimise_emptys_act(Accum,BE,BasicEmptys,NewAccum,NewAccum,MinimalEmptys).
> 
> d_minimise_emptys_act([],B,BsRest,NewAccum,[B],MEs) :-
>   d_minimise_emptys(BsRest,NewAccum,MEs).
> d_minimise_emptys_act([A|AsRest],B,BsRest,NewAccum,NARest,MEs) :-
>   A = empty(_,_,AFS,_,_),
>   B = empty(_,_,BFS,_,_),
>   empty_assoc(H),
>   empty_assoc(K),
>   subsume(s(AFS,BFS,sdone),<,>,LReln,RReln,H,K),
>   d_me_subsume_act(LReln,RReln,A,B,AsRest,BsRest,NewAccum,NARest,MEs).
> 
> d_me_subsume_act(<,_,A,_,AsRest,BsRest,NewAccum,[A|AsRest],MEs) :-
>  nl,write('EFD-closure discarded a subsumed empty category'),  
>   d_minimise_emptys(BsRest,NewAccum,MEs).
> d_me_subsume_act(#,>,_,B,AsRest,BsRest,NewAccum,NARest,MEs) :-
>  nl,write('EFD-closure discarded a subsumed empty category'),  
>   d_minimise_emptys_act(AsRest,B,BsRest,NewAccum,NARest,MEs).
> d_me_subsume_act(#,#,A,B,AsRest,BsRest,NewAccum,[A|NARest],MEs) :-
>   d_minimise_emptys_act(AsRest,B,BsRest,NewAccum,NARest,MEs).
> 
> d_close_emptys(Emptys,ClosedEmptys,ClosedRules) :-
>   findall(alec_rule(LabelledDtrs,_,LabelledMother,RuleName,PrevDtrs,PrevDtrs,
> 		    DtrStore,DtrStore,RuleLine,1),
> 	  (current_predicate(lrule,lrule(_,_,_,_)),
>            lrule(RuleName,RuleLine,LabelledMother,LabelledDtrs)),
>           Rules),
>   d_efd_iterate(Emptys,Rules,[],[],[],ClosedEmptys,ClosedRules).
> 
> d_efd_iterate([],Rules,NewRules,EmptyAccum,_RuleAccum,  % RuleAccum is []
>               ClosedEmptys,ClosedRules) :-
>   !,
>   (NewRules == []
>   -> ClosedEmptys = EmptyAccum, ClosedRules = Rules
>    ; d_efd_iterate(EmptyAccum,NewRules,[],[],Rules,ClosedEmptys,ClosedRules)
>   ).
> d_efd_iterate(Emptys,Rules,NewRules,EmptyAccum,RuleAccum,
>               ClosedEmptys,ClosedRules) :-
>   d_apply_once(Emptys,Rules,NewEmptysandRules),
>   split_emptys_rules(NewEmptysandRules,NewRules,NewRules1,NewEmptys),
>   append(Emptys,EmptyAccum,EmptyAccum1),
>   append(Rules,RuleAccum,Rules1),
>   d_efd_iterate(NewEmptys,Rules1,NewRules1,EmptyAccum1,[],
>                 ClosedEmptys,ClosedRules).
> 
> d_apply_once(Emptys,Rules,NewEmptysandRules) :-
>   findall(EmptyorRule,
>           (member(Empty,Emptys),
> %    write(user_error,empty), nl(user_error),
> %    flush_output(user_error), % DEBUG
> %	      arg(3,Empty,PPFS), pp_fs(PPFS), query_proceed, % DEBUG
>            member(alec_rule(LabelledDtrs,Node,LabelledMother,RuleName,PrevDtrs,
>                             PrevDtrsMid,DtrStore,DtrStoreMid,RuleLine,DtrNum),
>                   Rules),
> %    write(user_error,RuleName), nl(user_error), flush_output(user_error),
> 	      % DEBUG
>            d_meta_interp(apply_once(RuleName,Empty,DtrNum),RuleLine,
>                          d_match_cat_to_next_cat(LabelledDtrs,LabelledMother,
> 						 RuleName,RuleLine,PrevDtrs,
>                                                  PrevDtrsMid,DtrStore,DtrStoreMid,
> 						 Empty,EmptyorRule,Node,DtrNum))
> %				  arg(1,Empty,N), % DEBUG
> %                                  write(user_error,'matched '),write(user_error,N),
> %				  write(user_error,' to '),write(user_error,RuleName),
> %				  nl(user_error),flush_output(user_error)
> 	  ),
>           NewEmptysandRules).
> 
> d_match_cat_to_next_cat((lcat(LDtr),LRest),LabelledMother,RuleName,RuleLine,
>                         PrevDtrs,[empty(N,Node)|PrevDtrsMid],DtrStore,[FS|DtrStoreMid],
>                         empty(N,Node,FS,_,_),EmptyorRule,Node,DtrNum) :-
>   d_add_to(LDtr,FS,edge),
>   NewDtrNum is DtrNum + 1,
>   d_match_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,PrevDtrs,
>                       PrevDtrsMid,DtrStore,DtrStoreMid,EmptyorRule,Node,NewDtrNum).
> d_match_cat_to_next_cat(lcat(LDtr),LabelledMother,RuleName,_RuleLine,PrevDtrs,
>                         [empty(N,Node)],DtrStore,[FS],empty(N,Node,FS,_,_),
>                         empty(NewN,Node,FS2,PrevDtrs,RuleName),
> 			Node,_DtrNum) :-
>   d_add_to(LDtr,FS,edge),
>   d_add_to(LabelledMother,FS2,mother),
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   gen_emptynum(NewN).
> d_match_cat_to_next_cat((lsem_head(LDtr),LRest),LabelledMother,RuleName,
>                         RuleLine,PrevDtrs,[empty(N,Node)|PrevDtrsMid],DtrStore,[FS|DtrStoreMid],
>                         empty(N,Node,FS,_,_),EmptyorRule,Node,DtrNum) :-
>   d_add_to(LDtr,FS,edge),
>   NewDtrNum is DtrNum + 1,
>   d_match_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,PrevDtrs,
>                       PrevDtrsMid,DtrStore,DtrStoreMid,EmptyorRule,Node,NewDtrNum).
> d_match_cat_to_next_cat(lsem_head(LDtr),LabelledMother,RuleName,_RuleLine,
>                       PrevDtrs,[empty(N,Node)],DtrStore,[FS],empty(N,Node,FS,_,_),
>                       empty(NewN,Node,FS2,PrevDtrs,RuleName),Node,_DtrNum) :-
>   d_add_to(LDtr,FS,edge),
>   d_add_to(LabelledMother,FS2,mother),
>   d_apply_forall_rule(DtrStore,FS2,RuleName),
>   gen_emptynum(NewN).
> d_match_cat_to_next_cat((lcats(LDtrs),LRest),LabelledMother,RuleName,RuleLine,
>                         PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,Empty,EmptyorRule,Node,DtrNum) :-
>   d_add_to(LDtrs,DtrsFS,edge),
>   get_type(DtrsFS,DtrsType),
>   ( ale_lists_defined -> clause(fcolour(hd,HdPos,_),true),
>                          clause(fcolour(tl,TlPos,_),true)
>   ; strip_labels(LDtrs,Dtrs),
>     raise_exception(cats_no_lists(RuleName,Dtrs))
>   ),
>   (sub_type(ne_list,DtrsType)
>   -> arg(HdPos,DtrsFS,HdFS),
>      Empty = empty(N,Node,HdFS,_,_),
>      NewDtrNum is DtrNum + 1,
>      arg(TlPos,DtrsFS,TlFS),
>      get_type(TlFS,TlType),
>      (sub_type(ne_list,TlType)
>      -> PrevDtrsMid = [empty(N,Node)|PrevDtrsRest], DtrStoreMid = [HdFS|DtrStoreRest],
>         EmptyorRule = alec_rule((remainder(TlFS),LRest),Node,LabelledMother,
>                                 RuleName,PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest,
> 				RuleLine,NewDtrNum)
>       ; (sub_type(e_list,TlType)
>         -> PrevDtrsMid = [empty(N,Node)|PrevDtrsMid2], DtrStoreMid = [HdFS|DtrStoreMid2],
>            d_match_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,PrevDtrs,
>                                PrevDtrsMid2,DtrStore,DtrStoreMid2,EmptyorRule,Node,NewDtrNum)
>          ; error_msg((nl,write('error: cats> value with sort, '),write(TlType),
>                       write(' is not a valid list argument')))
>         )
>      )
>    ; (sub_type(e_list,DtrsType)
>      -> d_match_cat_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,
>                                 PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,Empty,EmptyorRule,Node,DtrNum)
>       ; error_msg((nl,write('error: cats> value with sort, '),write(DtrsType),
>                    write(' is not a valid list argument')))
>      )
>   ).
> d_match_cat_to_next_cat(lcats(LDtrs),LabelledMother,RuleName,RuleLine,PrevDtrs,
>                         PrevDtrsMid,DtrStore,DtrStoreMid,empty(N,Node,HdFS,_,_),EmptyorRule,Node,DtrNum) :-
>   d_add_to(LDtrs,DtrsFS,edge),
>   get_type(DtrsFS,DtrsType),
>   ( ale_lists_defined -> clause(fcolour(hd,HdPos,_),true),
>                          clause(fcolour(tl,TlPos,_),true)
>   ; strip_labels(LDtrs,Dtrs),
>     raise_exception(cats_no_lists(RuleName,Dtrs))
>   ),
>   (sub_type(ne_list,DtrsType)
>   -> arg(HdPos,DtrsFS,HdFS),
>      NewDtrNum is DtrNum + 1,
>      arg(TlPos,DtrsFS,TlFS),
>      get_type(TlFS,TlType),
>      (sub_type(ne_list,TlType)
>      -> PrevDtrsMid = [empty(N,Node)|PrevDtrsRest], DtrStoreMid = [HdFS|DtrStoreRest],
>         EmptyorRule = alec_rule(remainder(TlFS),Node,LabelledMother,RuleName,
>                                 PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest,RuleLine,NewDtrNum)
>       ; (sub_type(e_list,TlType)
>         -> d_add_to(LabelledMother,FS2,mother),
>            PrevDtrsMid = [empty(N,Node)], DtrStoreMid = [HdFS],
> 	   d_apply_forall_rule(DtrStore,FS2,RuleName),
>            EmptyorRule = empty(NewN,Node,FS2,PrevDtrs,RuleName),
>            gen_emptynum(NewN)
>          ; error_msg((nl,write('error: cats> value with sort, '),write(TlType),
>                       write(' is not a valid list argument')))
>         )
>      )
>    ; (sub_type(e_list,DtrsType)
>      -> error_msg((nl,write('error: rule '),write(RuleName),
>                    write(' has no daughters')))
>       ; error_msg((nl,write('error: cats> value with sort, '),write(DtrsType),
>                    write(' is not a valid list argument')))
>      )
>   ).
> d_match_cat_to_next_cat((remainder(RFS),LRest),LabelledMother,RuleName,
>                         RuleLine,PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,
>                         empty(N,Node,HdFS,_,_),EmptyorRule,Node,DtrNum) :-
>   clause(fcolour(hd,HdPos,_),true),
>   clause(fcolour(tl,TlPos,_),true),
>   arg(HdPos,RFS,HdFS),
>   NewDtrNum is DtrNum + 1,
>   arg(TlPos,RFS,TlFS),
>   get_type(TlFS,TlType),
>   (sub_type(ne_list,TlType)
>   -> PrevDtrsMid = [empty(N,Node)|PrevDtrsRest], DtrStoreMid = [HdFS|DtrStoreRest],
>      EmptyorRule = alec_rule(remainder(TlFS),Node,LabelledMother,RuleName,
>                              PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest,RuleLine,NewDtrNum)
>    ; (sub_type(e_list,TlType)
>      -> PrevDtrsMid = [empty(N,Node)|PrevDtrsMid2], DtrStoreMid = [HdFS|DtrStoreMid2],
>         d_match_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,PrevDtrs,
>                             PrevDtrsMid2,DtrStore,DtrStoreMid2,EmptyorRule,Node,NewDtrNum)
>       ; error_msg((nl,write('error: cats> value with sort, '),write(TlType),
>                    write(' is not a valid list argument')))
>      )
>   ).
> d_match_cat_to_next_cat(remainder(RFS),LabelledMother,RuleName,RuleLine,
>                         PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,
>                         empty(N,Node,HdFS,_,_),EmptyorRule,Node,DtrNum) :-
>   clause(fcolour(hd,HdPos,_),true),
>   clause(fcolour(tl,TlPos,_),true),
>   arg(HdPos,RFS,HdFS),
>   NewDtrNum is DtrNum + 1,
>   arg(TlPos,RFS,TlFS),
>   get_type(TlFS,TlType),
>   (sub_type(ne_list,TlType)
>   -> PrevDtrsMid = [empty(N,Node)|PrevDtrsRest], DtrStoreMid = [HdFS|DtrStoreRest],
>      EmptyorRule = alec_rule(remainder(TlFS),Node,LabelledMother,RuleName,
>                              PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest,RuleLine,NewDtrNum)
>    ; (sub_type(e_list,TlType)
>      -> d_add_to(LabelledMother,FS2,mother),
>         PrevDtrsMid = [empty(N,Node)], DtrStoreMid = [HdFS],
> 	d_apply_forall_rule(DtrStore,FS2,RuleName),
>         EmptyorRule = empty(NewN,Node,FS2,PrevDtrs,RuleName),
>         gen_emptynum(NewN)
>       ; error_msg((nl,write('error: cats> value with sort, '),write(TlType),
>                    write(' is not a valid list argument')))
>      )
>   ).
> d_match_cat_to_next_cat((lgoal(LGoalDesc),LRest),LabelledMother,RuleName,
>                         RuleLine,PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,Empty,
>                         EmptyorRule,Node,DtrNum) :-
>   d_query(LGoalDesc),
>   d_match_cat_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,PrevDtrs,
>                           PrevDtrsMid,DtrStore,DtrStoreMid,Empty,EmptyorRule,Node,DtrNum).
> d_match_cat_to_next_cat(lgoal(_),_,RuleName,_,_,_,_,_,_,_,_,_) :-
>   error_msg((nl,write('error: rule '),write(RuleName),
>              write(' has no daughters'))).
> d_match_cat_to_next_cat((lsem_goal(LGoalDesc),LRest),LabelledMother,RuleName,
>                         RuleLine,PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,Empty,
>                         EmptyorRule,Node,DtrNum) :-
>   d_query(LGoalDesc),
>   d_match_cat_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,PrevDtrs,
>                           PrevDtrsMid,DtrStore,DtrStoreMid,Empty,EmptyorRule,Node,DtrNum).
> d_match_cat_to_next_cat(lsem_goal(_),_,RuleName,_,_,_,_,_,_,_,_,_) :-
>   error_msg((nl,write('error: rule '),write(RuleName),
>              write(' has no daughters'))).
> 
> d_match_to_next_cat((lcat(LDtr),LRest),LabelledMother,RuleName,RuleLine,
>                     PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest,
>                     alec_rule((lcat(LDtr),LRest),Node,LabelledMother,RuleName,
>                               PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest,RuleLine,NewDtrNum),Node,NewDtrNum).
> d_match_to_next_cat(lcat(LDtr),LabelledMother,RuleName,RuleLine,PrevDtrs,
>                     PrevDtrsRest,DtrStore,DtrStoreRest,
>                     alec_rule(lcat(LDtr),Node,LabelledMother,RuleName,PrevDtrs,
>                               PrevDtrsRest,DtrStore,DtrStoreRest,RuleLine,NewDtrNum),Node,NewDtrNum).
> d_match_to_next_cat((lsem_head(LDtr),LRest),LabelledMother,RuleName,RuleLine,
>                     PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest,
>                     alec_rule((lsem_head(LDtr),LRest),Node,LabelledMother,RuleName,
>                               PrevDtrs,PrevDtrsRest,DtrStore,DtrStoreRest,RuleLine,NewDtrNum),Node,NewDtrNum).
> d_match_to_next_cat(lsem_head(LDtr),LabelledMother,RuleName,RuleLine,PrevDtrs,PrevDtrsRest,
> 		    DtrStore,DtrStoreRest,
>                     alec_rule(lsem_head(LDtr),Node,LabelledMother,RuleName,PrevDtrs,
>                               PrevDtrsRest,DtrStore,DtrStoreRest,RuleLine,NewDtrNum),Node,NewDtrNum).
> d_match_to_next_cat((lcats(LDtrs),LRest),LabelledMother,RuleName,RuleLine,
>                     PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,EmptyorRule,Node,NewDtrNum) :-
>   d_add_to(LDtrs,DtrsFS,dtrlist),
>   get_type(DtrsFS,DtrsType),
>   (sub_type(ne_list,DtrsType)
>   -> EmptyorRule = alec_rule((remainder(DtrsFS),LRest),Node,LabelledMother,
>                              RuleName,PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,RuleLine,NewDtrNum)
>    ; (sub_type(e_list,DtrsType)
>      -> d_match_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,PrevDtrs,
>                             PrevDtrsMid,DtrStore,DtrStoreMid,EmptyorRule,Node,NewDtrNum)
>       ; error_msg((nl,write('error: cats> value with sort, '),write(DtrsType),
>                    write(' is not a valid list argument')))
>      )
>   ).
> d_match_to_next_cat(lcats(LDtrs),LabelledMother,RuleName,RuleLine,PrevDtrs,
>                     PrevDtrsMid,DtrStore,DtrStoreMid,EmptyorRule,Node,NewDtrNum) :-
>   d_add_to(LDtrs,DtrsFS,dtrlist),
>   get_type(DtrsFS,DtrsType),
>   (sub_type(ne_list,DtrsType)
>   -> EmptyorRule = alec_rule(remainder(DtrsFS),Node,LabelledMother,RuleName,
>                              PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,RuleLine,NewDtrNum)
>    ; (sub_type(e_list,DtrsType)
>      -> d_add_to(LabelledMother,FS,mother),
>         PrevDtrsMid = [], DtrStoreMid = [],
> 	d_apply_forall_rule(DtrStore,FS,RuleName),
>         EmptyorRule = empty(NewN,Node,FS,PrevDtrs,RuleName),
>         gen_emptynum(NewN)
>       ; error_msg((nl,write('error: cats> value with sort, '),write(DtrsType),
>                    write(' is not a valid list argument')))
>      )
>   ).
> d_match_to_next_cat((lgoal(LGoalDesc),LRest),LabelledMother,RuleName,RuleLine,
>                     PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,EmptyorRule,Node,NewDtrNum) :-
>   d_query(LGoalDesc),
>   d_match_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,PrevDtrs,
>                       PrevDtrsMid,DtrStore,DtrStoreMid,EmptyorRule,Node,NewDtrNum).
> d_match_to_next_cat(lgoal(LGoalDesc),LabelledMother,RuleName,_RuleLine,
>                     PrevDtrs,[],DtrStore,[],
>                     empty(NewN,Node,FS,PrevDtrs,RuleName),Node,_NewDtrNum) :-
>   d_query(LGoalDesc),
>   d_add_to(LabelledMother,FS,mother),
>   d_apply_forall_rule(DtrStore,FS,RuleName),
>   gen_emptynum(NewN).
> d_match_to_next_cat((lsem_goal(LGoalDesc),LRest),LabelledMother,RuleName,
>                     RuleLine,PrevDtrs,PrevDtrsMid,DtrStore,DtrStoreMid,EmptyorRule,Node,NewDtrNum) :-
>   d_query(LGoalDesc),
>   d_match_to_next_cat(LRest,LabelledMother,RuleName,RuleLine,PrevDtrs,
>                       PrevDtrsMid,DtrStore,DtrStoreMid,EmptyorRule,Node,NewDtrNum).
> d_match_to_next_cat(lsem_goal(LGoalDesc),LabelledMother,RuleName,_RuleLine,
>                     PrevDtrs,[],DtrStore,[],
>                     empty(NewN,Node,FS,PrevDtrs,RuleName),Node,_NewDtrNum) :-
>   d_query(LGoalDesc),
>   d_add_to(LabelledMother,FS,mother),
>   d_apply_forall_rule(DtrStore,FS,RuleName),
>   gen_emptynum(NewN).
> 
> 
> %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> % Utilities
> 
> :- dynamic d_mode/1.
> set_d_mode(Mode) :-
>   retractall(d_mode(_)),
>   assert(d_mode(Mode)).
> 
> set_d_mode(OldMode,Mode) :-
>   (d_mode(OldMode) -> true ; OldMode = creep),  % in case we forgot, guess creep
>   set_d_mode(Mode).
> 	
> reset_d_mode :-
>   set_d_mode(creep).
> 
> set_d_skip_level(S) :-
>   retractall(d_skip_level(_)),
>   asserta(d_skip_level(S)).  % need asserta/1 for buggy Win32 SICStus
> 
> reset_d_skip_level :-
>   set_d_skip_level(0).
> 
> set_ale_break(Line) :-
>  (current_predicate(ale_break,ale_break(_)),
>   ale_break(Line)) -> format(user_error, '{Breakpoint already set}~n', []),
>                       flush_output(user_error)
>  ; Line == [] -> format(user_error, '{Could not set breakpoint}~n', []),
>                  flush_output(user_error)
>  ; assert(ale_break(Line)).
> 
> reset_ale_break(Line) :-
>  (current_predicate(ale_break,ale_break(_)),
>   retract(ale_break(Line))) -> true
>  ; format(user_error, '{No breakpoint at that line}~n', []),
>    flush_output(user_error).
> 
> switch_off_prolog_debugger :-
>   ( d_mode(creep) -> (notrace ; (trace,fail))
>   ; true).
> 
> d_chain_rule_body(lsem_head(_)).
> d_chain_rule_body((lsem_head(_),_)) :-
>   !.
> d_chain_rule_body((_,Rest)) :-
>   d_chain_rule_body(Rest).
> 
> 
> d_chain_rule_body((lsem_goal(LGoalBefore),lsem_head(LSemHead),
>                    lsem_goal(LGoalAfter),_Rest),
>                   LGoalBefore,LSemHead,LGoalAfter) :-
>   !.
> d_chain_rule_body((lsem_goal(LGoalBefore),lsem_head(LSemHead),
>                    lsem_goal(LGoalAfter)),
>                   LGoalBefore,LSemHead,LGoalAfter) :-
>   !.
> d_chain_rule_body((lsem_head(LSemHead),lsem_goal(LGoalAfter),_Rest),
>                   empty,LSemHead,LGoalAfter) :-
>   !.
> d_chain_rule_body((lsem_head(LSemHead),lsem_goal(LGoalAfter)),
>                   empty,LSemHead,LGoalAfter) :-
>   !.
> d_chain_rule_body((lsem_goal(LGoalBefore),lsem_head(LSemHead),
>                    _Rest),
>                   LGoalBefore,LSemHead,empty) :-
>   !.
> d_chain_rule_body((lsem_goal(LGoalBefore),lsem_head(LSemHead)),
>                   LGoalBefore,LSemHead,empty) :-
>   !.
> d_chain_rule_body((lsem_head(LSemHead),_Rest),
>                   empty,LSemHead,empty) :-
>   !.
> d_chain_rule_body(lsem_head(LSemHead),
>                   empty,LSemHead,empty) :-
>   !.
> d_chain_rule_body((_,Rest),LGoalBefore,LSemHead,LGoalAfter) :-
>   d_chain_rule_body(Rest,LGoalBefore,LSemHead,LGoalAfter).
> 
> 
> d_chain_rule_body((lsem_goal(LGoalBefore),lsem_head(LSemHead),
>                    lsem_goal(LGoalAfter),Rest),
>                   LGoalBefore,LSemHead,LGoalAfter,empty,Rest) :-
>   !.
> d_chain_rule_body((lsem_goal(LGoalBefore),lsem_head(LSemHead),
>                    lsem_goal(LGoalAfter)),
>                   LGoalBefore,LSemHead,LGoalAfter,empty,empty) :-
>   !.
> d_chain_rule_body((lsem_head(LSemHead),lsem_goal(LGoalAfter),Rest),
>                   empty,LSemHead,LGoalAfter,empty,Rest) :-
>   !.
> d_chain_rule_body((lsem_head(LSemHead),lsem_goal(LGoalAfter)),
>                   empty,LSemHead,LGoalAfter,empty,empty) :-
>   !.
> d_chain_rule_body((lsem_goal(LGoalBefore),lsem_head(LSemHead),
>                    Rest),
>                   LGoalBefore,LSemHead,empty,empty,Rest) :-
>   !.
> d_chain_rule_body((lsem_goal(LGoalBefore),lsem_head(LSemHead)),
>                   LGoalBefore,LSemHead,empty,empty,empty) :-
>   !.
> d_chain_rule_body((lsem_head(LSemHead),Rest),
>                   empty,LSemHead,empty,empty,Rest) :-
>   !.
> d_chain_rule_body(lsem_head(LSemHead),
>                   empty,LSemHead,empty,empty,empty) :-
>   !.
> d_chain_rule_body((OtherDtr,Rest),LGoalBefore,LSemHead,LGoalAfter,
>                   (OtherDtr,Others),NextDtrs) :-
>   d_chain_rule_body(Rest,LGoalBefore,LSemHead,LGoalAfter,Others,NextDtrs).
> 
> 
> capture_macro_vars(LD,MacroHead,LMD) :-
>   MacroHead =.. [_|MacroVars],
>   cmv_desc(LD,MacroVars,LMD).
> 
> cmv_desc(lvar(X,XName,XLine),MacroVars,NewX) :-
>   !,(member_eq(X,MacroVars) -> 
>       NewX = X
>     ; NewX = lvar(X,XName,XLine)).
> cmv_desc(lnelist(HeadLine,TailLine,LH,LT),MacroVars,
>         lnelist(HeadLine,TailLine,NewLH,NewLT)) :-
>   !,cmv_desc(LH,MacroVars,NewLH),
>   cmv_desc(LT,MacroVars,NewLT).
> cmv_desc(lineq(OpLine,LD),MacroVars,lineq(OpLine,NewLD)) :-
>   !,cmv_desc(LD,MacroVars,NewLD).
> cmv_desc(LF:LD,MacroVars,LF:NewLD) :-
>   !,cmv_desc(LD,MacroVars,NewLD).
> cmv_desc((LD1,LD2),MacroVars,(NewLD1,NewLD2)) :-
>   !,cmv_desc(LD1,MacroVars,NewLD1),
>   cmv_desc(LD2,MacroVars,NewLD2).
> cmv_desc((LD1;LD2),MacroVars,(NewLD1;NewLD2)) :-
>   !,cmv_desc(LD1,MacroVars,NewLD1),
>   cmv_desc(LD2,MacroVars,NewLD2).
> cmv_desc(lmac(MacroCall,OpLine),MacroVars,lmac(NewMacroCall,OpLine)) :-
>   !,MacroCall =.. [Name|ArgDescs],
>   cmv_desc_list(ArgDescs,MacroVars,NewArgDescs),
>   NewMacroCall =.. [Name|NewArgDescs].
> cmv_desc(lfun(lcomp(Functor,Arity,FunLine,LDList)),MacroVars,
>         lfun(lcomp(Functor,Arity,FunLine,NewLDList))) :-
>   !,cmv_desc_list(LDList,MacroVars,NewLDList).
> cmv_desc(Other,_,Other).
> 
> cmv_desc_list([],_,[]).
> cmv_desc_list([LD|LDs],MacroVars,[NewLD|NewLDs]) :-
>   cmv_desc(LD,MacroVars,NewLD),
>   cmv_desc_list(LDs,MacroVars,NewLDs).
> 
> cmv_body((LB1,LB2),MacroVars,(NewLB1,NewLB2)) :-
>   !,cmv_body(LB1,MacroVars,NewLB1),
>   cmv_body(LB2,MacroVars,NewLB2).
> cmv_body((LB1;LB2),MacroVars,(NewLB1;NewLB2)) :-
>   !,cmv_body(LB1,MacroVars,NewLB1),
>   cmv_body(LB2,MacroVars,NewLB2).
> cmv_body(lshallow(ArrowLabel,LIf,LThen,LElse),MacroVars,
> 	 lshallow(ArrowLabel,NewLIf,NewLThen,NewLElse)) :-
>   !,cmv_body(LIf,MacroVars,NewLIf),
>   cmv_body(LThen,MacroVars,NewLThen),
>   cmv_body(LElse,MacroVars,NewLElse).
> cmv_body(lneg(NegLabel,LBody),MacroVars,lneg(NegLabel,NewLBody)) :-
>   !,cmv_body(LBody,MacroVars,NewLBody).
> cmv_body(lexteq(OpLabel,LD1,LD2),MacroVars,lexteq(OpLabel,NewLD1,NewLD2)) :-
>   !,cmv_desc(LD1,MacroVars,NewLD1),
>   cmv_desc(LD2,MacroVars,NewLD2).
> cmv_body(lunify(OpLabel,LD1,LD2),MacroVars,lunify(OpLabel,NewLD1,NewLD2)) :-
>   !,cmv_desc(LD1,MacroVars,NewLD1),
>   cmv_desc(LD2,MacroVars,NewLD2).
> cmv_body(lwhen(OpLabel,Cond,LB),MacroVars,lwhen(OpLabel,Cond,NewLB)) :-
>   !,cmv_body(LB,MacroVars,NewLB).
> cmv_body(lcomp(Functor,Arity,FunLine,LDList),MacroVars,
> 	 lcomp(Functor,Arity,FunLine,NewLDList)) :-
>   !,cmv_desc_list(LDList,MacroVars,NewLDList).
> cmv_body(Other,_,Other).
> 
> strip_immed_left_paren(['('|TokenS],TokenS) :-
>   !. % if left paren doesn't immediately follow, delimiter will include space
> strip_immed_left_paren(TokenS,TokenS).
> 
> % trunc_select/3 - like select/3 except only returns portion of remainder
> %  that occurs after selected element.
> 
> trunc_select(X,[X|Rest],Rest) :-
>   !.
> trunc_select(X,[_Y|List],Rest) :-
>   trunc_select(X,List,Rest).
> 
> select_var([],_,'_'). % must be anonymous if not in list
> select_var([(Name = Y)|Va],X,XName) :-
>   (X == Y)
>   -> Name = XName
>   ; select_var(Va,X,XName).
> 
> %my_read_tokens(GramS,TokenS,Vars) :-
> %  prolog:'$input'(Current,GramS),
> %  source_debug:xread_tokens(TokenS,Vars),
> %  prolog:'$input'(_,Current).
> 
> abolish_lpreds :-
>   abolish('l--->',3),abolish(lif,2),abolish('l+++>',2),abolish(llr,3),
>   abolish(lrule,4),abolish(lmacro,3),abolish(lemptyentry,2), abolish(lcons,5),
>   abolish(lsemantics,2), abolish(lclosedrule,9), abolish(empty_cat,5),
>   retractall(ale_debugging), retractall(ale_debug(_)), abolish(ale_break,1).
> % abolish(ale_breakable_lines,1).
> 
> space :- write(user_error,' ').
> 
> %tread(T,V) :-
> %  hstream(S),
> %  prolog:'$input'(Curr,S),
> %  source_debug:xread_tokens(T,V),
> %  assert(foo(T,V)),
> %  prolog:'$input'(_,Curr).
> 
> % V contains a mapping of RefVars to char codes for each instance of a 
> % *named* var
> 
> %tparse(T,Term,Left) :-
> %  source_debug:read(T,1200,Term,Left).
> 
> %tinit(F,S) :-
> %  open(F,read,S),
> %  assert(hstream(S)).
> 
> :- nl,write('
> ALE Source-Level Debugger Version 3.2.1; December, 2001
> Copyright (C) 1997--1999, 2001, Gerald Penn
> All rights reserved'),nl,
>   nodlex,
>   reset_d_mode.
diff -rN trale.orig/debugger/step_id_display_hooks.pl trale/debugger/step_id_display_hooks.pl
0a1,97
> % ------------------------------------------------------------------------------
> %
> % step_id_display_hooks.pl
> %
> % Author: Kilian Evang
> %
> % These hook implementations exemplify how to maintain a model of the parsing
> % call stack using the newly added hooks of TRALE's source-level debugger:
> %
> % announce_parse_begin_hook/1 is called before parsing starts. It is used to
> % clean up and initialize dynamic predicates.
> %
> % announce_step_hook/3 is called immediately before the first call to a
> % parsing step. It conveys the invocation identifier of the parsing step as
> % well as associated data. The client remembers what it needs to remember. In
> % particular, it marks the step as "about to be called".
> % 
> % announce_call_hook/0 is called at the call port of the parsing step. The
> % client pushes the step onto the stack at this point.
> %
> % announce_fail_hook/0 is called if and when the parsing step fails. The client
> % pops the step off the stack, but marks it as "about to be called" in case the
> % user forces a Retry.
> %
> % announce_finished_hook/0 is a variant of announce_fail_hook/0 called to
> % indicate the Prolog-wise failure but parsing-wise success of certain parsing
> % steps that are implemented in a failure-driven fashion.
> %
> % announce_exit_hook/0 is called if and when the parsing step succeeds. As far
> % as maintenance of the stack model is concerned, the client handles this
> % exactly like the fail case.
> %
> % announce_redo_hook/1 is called if and when a step is redone in order to
> % obtain more solutions because a step later in the execution has failed. The ID
> % of the step is re-communicated. The client pushes the step onto the stack, but
> % also marks it as "about to be called" in case the user forces a complete Retry
> % of the step.
> %
> % announce_edge_added_hook/4 is called to announce that an edge has been added
> % to the chart.
> %
> % announce_edge_retrieved_hook/1 is called to announce that an edge has been
> % retrieved from the chart.
> %
> % ------------------------------------------------------------------------------
> 
> :- dynamic sid_stack/1.
> :- dynamic sid_next_step/1.
> 
> announce_parse_begin_hook(_Words) :-
>   retractall(sid_stack(_)),
>   retractall(sid_next_step(_)),
>   asserta(sid_stack([])).
> 
> announce_step_hook(StepID,_Command,_Line) :-
>   sid_set_next_step(StepID).
> 
> announce_call_hook :-
>   sid_next_step(StepID),
>   sid_push(StepID),
>   write(StepID), write('\t').
> 
> announce_fail_hook :-
>   sid_pop(StepID),
>   sid_set_next_step(StepID), % may be retried
>   write(StepID), write('\t').
> 
> announce_finished_hook :-
>   sid_pop(StepID),
>   sid_set_next_step(StepID), % may be retried
>   write(StepID), write('\t').
> 
> announce_exit_hook :-
>   sid_pop(StepID),
>   sid_set_next_step(StepID), % may be retried
>   write(StepID), write('\t').
> 
> announce_redo_hook(StepID) :-
>   sid_push(StepID),
>   sid_set_next_step(StepID), % may be retried
>   write(StepID), write('\t').
>   
> announce_edge_added_hook(_Number,_Left,_Right,_RuleName).
> 
> announce_edge_retrieved_hook(_Number).
> 
> sid_set_next_step(StepID) :-
>   retractall(sid_next_step(_)),
>   asserta(sid_next_step(StepID)).
> 
> sid_push(StepID) :-
>   retract(sid_stack(Stack)),
>   asserta(sid_stack([StepID|Stack])).
>   
> sid_pop(StepID) :-
>   retract(sid_stack([StepID|Rest])),
>   asserta(sid_stack(Rest)).
diff -rN trale.orig/debugger/step_id_display_hooks.pl~ trale/debugger/step_id_display_hooks.pl~
0a1,57
> % ------------------------------------------------------------------------------
> %
> % These hooks exemplify the slightly twisted logic required in order to maintain
> % a call stack using the hooks now provided by TRALE's debugger. A step is
> % presented using announce_step_hook/3 immediately before it is first called.
> % The call, fail, and exit ports are announced without any arguments; it must
> % be inferred from the stack what step these announcements refer to. The exit
> % and fail ports prompt popping the topmost step from the stack. The redo port
> % explicitly announce what step is being redone using the step invocation ID.
> % announce_step_hook/3 and announce_redo/1 prompt pushing the respective step
> % onto the stack. In this example, steps are represented only by numbers. If a
> % client application wishes to associate more data with steps, notably data from
> % the Command and Line arguments from announce_step_hook/3, it must maintain its
> % own mapping of step IDs to associated data so the data can be re-pushed onto
> % the stack in case the step is redone.
> %
> % Author: Kilian Evang
> %
> % ------------------------------------------------------------------------------
> 
> :- dynamic sid_stack/1.
> :- dynamic sid_next_step/1.
> 
> announce_parse_begin_hook(_Words) :-
>   retractall(sid_stack(_)),
>   retractall(sid_next_step(_)),
>   asserta(sid_stack([])).
> 
> announce_step_hook(StepID,_Command,_Line) :-
>   retractall(sid_next_step(_)),
>   write('s'), write(StepID), nl,
>   asserta(sid_next_step(StepID)).
> 
> announce_call_hook :-
>   retract(sid_next_step(StepID)),
>   retract(sid_stack(Stack)),
>   write('c'), write(StepID), write('\t'),
>   asserta(sid_stack([StepID|Stack])).
> 
> announce_fail_hook :-
>   retract(sid_stack([StepID|Rest])),
>   write('f'), write(StepID), write('\t'),
>   asserta(sid_next_step(StepID)), % may be retried
>   asserta(sid_stack(Rest)).
> 
> announce_exit_hook :-
>   retract(sid_stack([StepID|Rest])),
>   write('e'), write(StepID), write('\t'),
>   asserta(sid_next_step(StepID)), % may be retried
>   asserta(sid_stack(Rest)).
> 
> announce_redo_hook(StepID) :-
>   retract(sid_next_step(_)),
>   retract(sid_stack(Stack)),
>   write('r'), write(StepID), write('\t'),
>   asserta(sid_next_step(StepID)), % may be retried
>   asserta(sid_stack([StepID|Stack])).
diff -rN trale.orig/.project trale/.project
0a1,23
> <?xml version="1.0" encoding="UTF-8"?>
> <projectDescription>
> 	<name>trale</name>
> 	<comment></comment>
> 	<projects>
> 	</projects>
> 	<buildSpec>
> 		<buildCommand>
> 			<name>ar.com.tadp.prolog.PrologProjectBuilder</name>
> 			<arguments>
> 			</arguments>
> 		</buildCommand>
> 		<buildCommand>
> 			<name>org.cs3.pdt.core.PrologBuilder</name>
> 			<arguments>
> 			</arguments>
> 		</buildCommand>
> 	</buildSpec>
> 	<natures>
> 		<nature>org.cs3.pdt.core.PDTProjectNature</nature>
> 		<nature>ar.com.tadp.prolog.PrologProjectNature</nature>
> 	</natures>
> </projectDescription>
diff -rN trale.orig/startup.pl trale/startup.pl
152a153,155
> % load hooks for the graphical SLD
> :- ensure_loaded(trale_home('debugger/step_id_display_hooks')).
> 
diff -rN trale.orig/step_id_display_hooks.pl trale/step_id_display_hooks.pl
0a1,51
> % ------------------------------------------------------------------------------
> %
> % These hooks exemplify the slightly twisted logic required in order to maintain
> % a call stack using the hooks now provided by TRALE's debugger. A step is
> % presented using announce_step_hook/3 immediately before it is first called.
> % The call, fail, and exit ports are announced without any arguments; it must
> % be inferred from the stack what step these announcements refer to. The exit
> % and fail ports prompt popping the topmost step from the stack. The redo port
> % explicitly announce what step is being redone using the step invocation ID.
> % announce_step_hook/3 and announce_redo/1 prompt pushing the respective step
> % onto the stack. In this example, steps are represented only by numbers. If a
> % client application wishes to associate more data with steps, notably data from
> % the Command and Line arguments from announce_step_hook/3, it must maintain its
> % own mapping of step IDs to associated data so the data can be re-pushed onto
> % the stack in case the step is redone.
> %
> % Author: Kilian Evang
> %
> % ------------------------------------------------------------------------------
> 
> :- dynamic sid_stack/1.
> 
> :- write('UNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBARUNUEBERSEHBAR').
> 
> announce_parse_begin_hook(_Words) :-
> write('asdfasdfa'),
>   retractall(sid_stack(_)),
>   asserta(sid_stack([])).
> 
> announce_step_hook(StepID,_Command,_Line) :-
>   retract(sid_stack(Stack)),
>   asserta(sid_stack([StepID|Stack])).
> 
> announce_call_hook :-
>   sid_stack([StepID|_]),
>   write(StepID), tab.
> 
> announce_fail_hook :-
>   retract(sid_stack([StepID|Rest])),
>   write(StepID), tab,
>   asserta(sid_stack(Rest)).
> 
> announce_exit_hook :-
>   retract(sid_stack([StepID|Rest])),
>   write(StepID), tab,
>   asserta(sid_stack(Rest)).
> 
> announce_redo_hook(StepID) :-
>   retract(sid_stack(Stack)),
>   write(StepID), tab,
>   asserta(sid_stack([StepID|Stack])).
\ No newline at end of file
